{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/constants.ts\nvar cssPrefix = \"lk\";\n\n// src/utils.ts\nimport { LocalParticipant, RemoteParticipant } from \"livekit-client\";\n\n// src/track-reference/track-reference.types.ts\nfunction isTrackReference(trackReference) {\n  if (typeof trackReference === \"undefined\") {\n    return false;\n  }\n  return isTrackReferenceSubscribed(trackReference) || isTrackReferencePublished(trackReference);\n}\nfunction isTrackReferenceSubscribed(trackReference) {\n  var _a;\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"track\") && typeof ((_a = trackReference.publication) == null ? void 0 : _a.track) !== \"undefined\";\n}\nfunction isTrackReferencePublished(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"publication\") && typeof trackReference.publication !== \"undefined\";\n}\nfunction isTrackReferencePlaceholder(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && typeof trackReference.publication === \"undefined\";\n}\n\n// src/track-reference/track-reference.utils.ts\nfunction getTrackReferenceId(trackReference) {\n  if (typeof trackReference === \"string\" || typeof trackReference === \"number\") {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\nfunction getTrackReferenceSource(trackReference) {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\nfunction isEqualTrackRef(a, b) {\n  if (a === void 0 || b === void 0) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\nfunction isTrackReferencePinned(trackReference, pinState) {\n  if (typeof pinState === \"undefined\") {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReference(pinnedTrackReference) && pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid);\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReferencePlaceholder(pinnedTrackReference) && pinnedTrackReference.source === trackReference.source);\n  } else {\n    return false;\n  }\n}\nfunction isPlaceholderReplacement(currentTrackRef, nextTrackRef) {\n  return isTrackReferencePlaceholder(currentTrackRef) && isTrackReference(nextTrackRef) && nextTrackRef.participant.identity === currentTrackRef.participant.identity && nextTrackRef.source === currentTrackRef.source;\n}\n\n// src/utils.ts\nfunction isLocal(p) {\n  return p instanceof LocalParticipant;\n}\nfunction isRemote(p) {\n  return p instanceof RemoteParticipant;\n}\nvar attachIfSubscribed = (publication, element) => {\n  if (!publication) return;\n  const {\n    isSubscribed,\n    track\n  } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\nfunction isParticipantTrackReferencePinned(trackRef, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(pinnedTrackRef => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\nfunction getScrollBarWidth() {\n  const inner = document.createElement(\"p\");\n  inner.style.width = \"100%\";\n  inner.style.height = \"200px\";\n  const outer = document.createElement(\"div\");\n  outer.style.position = \"absolute\";\n  outer.style.top = \"0px\";\n  outer.style.left = \"0px\";\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"200px\";\n  outer.style.height = \"150px\";\n  outer.style.overflow = \"hidden\";\n  outer.appendChild(inner);\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n\n// src/helper/detectMobileBrowser.ts\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isMobileBrowser() {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n\n// src/helper/url-regex.ts\nfunction createUrlRegExp(options) {\n  options = __spreadValues({}, options);\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n  const ip = new RegExp(\"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\", \"g\").source;\n  const host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  const domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = \"(?::\\\\d{2,5})?\";\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex2 = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n  return options.exact ? new RegExp(`(?:^${regex2}$)`, \"i\") : new RegExp(regex2, \"ig\");\n}\n\n// src/helper/emailRegex.ts\nvar regex = \"[^\\\\.\\\\s@:](?:[^\\\\s@:]*[^\\\\s@:\\\\.])?@[^\\\\.\\\\s@]+(?:\\\\.[^\\\\.\\\\s@]+)*\";\nfunction createEmailRegExp({\n  exact\n} = {}) {\n  return exact ? new RegExp(`^${regex}$`) : new RegExp(regex, \"g\");\n}\n\n// src/helper/floating-menu.ts\nimport { computePosition, flip, offset, shift } from \"@floating-ui/dom\";\nfunction computeMenuPosition(button, menu) {\n  return __async(this, null, function* () {\n    const {\n      x,\n      y\n    } = yield computePosition(button, menu, {\n      placement: \"top\",\n      middleware: [offset(6), flip(), shift({\n        padding: 5\n      })]\n    });\n    return {\n      x,\n      y\n    };\n  });\n}\nfunction wasClickOutside(insideElement, event) {\n  const isOutside = !insideElement.contains(event.target);\n  return isOutside;\n}\n\n// src/helper/tokenizer.ts\nvar createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({})\n  };\n};\nfunction tokenize(input, grammar) {\n  const matches = Object.entries(grammar).map(([type, rx], weight) => Array.from(input.matchAll(rx)).map(({\n    index,\n    0: content\n  }) => ({\n    type,\n    weight,\n    content,\n    index: index != null ? index : 0\n  }))).flat().sort((a, b) => {\n    const d = a.index - b.index;\n    return d !== 0 ? d : a.weight - b.weight;\n  }).filter(({\n    index\n  }, i, arr) => {\n    if (i === 0) return true;\n    const prev = arr[i - 1];\n    return prev.index + prev.content.length <= index;\n  });\n  const tokens = [];\n  let pos = 0;\n  for (const {\n    type,\n    content,\n    index\n  } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({\n      type,\n      content\n    });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n\n// src/helper/eventGroups.ts\nimport { ParticipantEvent, RoomEvent } from \"livekit-client\";\nvar allRemoteParticipantRoomEvents = [RoomEvent.ConnectionStateChanged, RoomEvent.RoomMetadataChanged, RoomEvent.ActiveSpeakersChanged, RoomEvent.ConnectionQualityChanged, RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantPermissionsChanged, RoomEvent.ParticipantMetadataChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackPublished, RoomEvent.TrackUnpublished, RoomEvent.TrackStreamStateChanged, RoomEvent.TrackSubscriptionFailed, RoomEvent.TrackSubscriptionPermissionChanged, RoomEvent.TrackSubscriptionStatusChanged];\nvar allParticipantRoomEvents = [...allRemoteParticipantRoomEvents, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished];\nvar participantTrackEvents = [ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscribed, ParticipantEvent.TrackUnsubscribed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\nvar allRemoteParticipantEvents = [ParticipantEvent.ConnectionQualityChanged, ParticipantEvent.IsSpeakingChanged, ParticipantEvent.ParticipantMetadataChanged, ParticipantEvent.ParticipantPermissionsChanged, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionStatusChanged];\nvar allParticipantEvents = [...allRemoteParticipantEvents, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\n\n// src/logger.ts\nimport { setLogLevel as setClientSdkLogLevel, setLogExtension as setClientSdkLogExtension, LogLevel as LogLevelEnum } from \"livekit-client\";\nimport loglevel from \"loglevel\";\nvar log = loglevel.getLogger(\"lk-components-js\");\nlog.setDefaultLevel(\"WARN\");\nfunction setLogLevel(level, options = {}) {\n  var _a;\n  log.setLevel(level);\n  setClientSdkLogLevel((_a = options.liveKitClientLogLevel) != null ? _a : level);\n}\nfunction setLogExtension(extension, options = {}) {\n  var _a;\n  const originalFactory = log.methodFactory;\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n    return (msg, context) => {\n      if (context) rawMethod(msg, context);else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel());\n  setClientSdkLogExtension((_a = options.liveKitClientLogExtension) != null ? _a : extension);\n}\n\n// src/helper/grid-layouts.ts\nvar GRID_LAYOUTS = [{\n  columns: 1,\n  rows: 1,\n  name: \"1x1\",\n  minTiles: 1,\n  maxTiles: 1,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 1,\n  rows: 2,\n  name: \"1x2\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 1,\n  name: \"2x1\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 900,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 2,\n  name: \"2x2\",\n  minTiles: 3,\n  maxTiles: 4,\n  minWidth: 560,\n  minHeight: 0\n}, {\n  columns: 3,\n  rows: 3,\n  name: \"3x3\",\n  minTiles: 5,\n  maxTiles: 9,\n  minWidth: 700,\n  minHeight: 0\n}, {\n  columns: 4,\n  rows: 4,\n  name: \"4x4\",\n  minTiles: 10,\n  maxTiles: 16,\n  minWidth: 960,\n  minHeight: 0\n}, {\n  columns: 5,\n  rows: 5,\n  name: \"5x5\",\n  minTiles: 17,\n  maxTiles: 25,\n  minWidth: 1100,\n  minHeight: 0\n}];\nfunction selectGridLayout(layouts, participantCount, width, height) {\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable = allLayouts.findIndex((l, i) => {\n      const layoutIsBiggerThanCurrent = i > index;\n      const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n      return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n    }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === void 0) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(`No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`);\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n  if (width < layout.minWidth || height < layout.minHeight) {\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(layouts.slice(0, currentLayoutIndex), smallerLayout.maxTiles, width, height);\n    }\n  }\n  return layout;\n}\n\n// src/helper/set-helper.ts\nfunction setDifference(setA, setB) {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\n// src/helper/featureDetection.ts\nfunction supportsScreenSharing() {\n  return typeof navigator !== \"undefined\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\n}\n\n// src/helper/transcriptions.ts\nfunction getActiveTranscriptionSegments(segments, syncTimes, maxAge = 0) {\n  return segments.filter(segment => {\n    var _a;\n    const hasTrackSync = !!syncTimes.rtpTimestamp;\n    const currentTrackTime = (_a = syncTimes.rtpTimestamp) != null ? _a : performance.timeOrigin + performance.now();\n    const displayStartTime = hasTrackSync ? Math.max(segment.receivedAtMediaTimestamp, segment.startTime) : segment.receivedAt;\n    const segmentDuration = maxAge + segment.endTime - segment.startTime;\n    return currentTrackTime >= displayStartTime && currentTrackTime <= displayStartTime + segmentDuration;\n  });\n}\nfunction addMediaTimestampToTranscription(segment, timestamps) {\n  var _a;\n  return __spreadProps(__spreadValues({}, segment), {\n    receivedAtMediaTimestamp: (_a = timestamps.rtpTimestamp) != null ? _a : 0,\n    receivedAt: timestamps.timestamp\n  });\n}\nfunction dedupeSegments(prevSegments, newSegments, windowSize) {\n  return [...prevSegments, ...newSegments].reduceRight((acc, segment) => {\n    if (!acc.find(val => val.id === segment.id)) {\n      acc.unshift(segment);\n    }\n    return acc;\n  }, []).slice(0 - windowSize);\n}\nfunction didActiveSegmentsChange(prevActive, newActive) {\n  if (newActive.length !== prevActive.length) {\n    return true;\n  }\n  return !newActive.every(newSegment => {\n    return prevActive.find(prevSegment => prevSegment.id === newSegment.id && prevSegment.text === newSegment.text && prevSegment.final === newSegment.final && prevSegment.language === newSegment.language && prevSegment.startTime === newSegment.startTime && prevSegment.endTime === newSegment.endTime);\n  });\n}\n\n// src/types.ts\nvar PIN_DEFAULT_STATE = [];\nvar WIDGET_DEFAULT_STATE = {\n  showChat: false,\n  unreadMessages: 0,\n  showSettings: false\n};\nfunction isSourceWitOptions(source) {\n  return typeof source === \"object\";\n}\nfunction isSourcesWithOptions(sources) {\n  return Array.isArray(sources) && sources.filter(isSourceWitOptions).length > 0;\n}\n\n// src/sorting/sort-track-bundles.ts\nimport { Track as Track2 } from \"livekit-client\";\n\n// src/sorting/base-sort-functions.ts\nimport { Track } from \"livekit-client\";\nfunction sortParticipantsByAudioLevel(a, b) {\n  return b.audioLevel - a.audioLevel;\n}\nfunction sortParticipantsByIsSpeaking(a, b) {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\nfunction sortParticipantsByLastSpokenAT(a, b) {\n  var _a, _b, _c, _d;\n  if (a.lastSpokeAt !== void 0 || b.lastSpokeAt !== void 0) {\n    return ((_b = (_a = b.lastSpokeAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = a.lastSpokeAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n  } else {\n    return 0;\n  }\n}\nfunction sortParticipantsByJoinedAt(a, b) {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = a.joinedAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = b.joinedAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n}\nfunction sortTrackReferencesByType(a, b) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction sortTrackRefsByIsCameraEnabled(a, b) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n// src/sorting/sort-track-bundles.ts\nfunction sortTrackReferences(tracks) {\n  const localTracks = [];\n  const screenShareTracks = [];\n  const cameraTracks = [];\n  const undefinedTracks = [];\n  tracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal && trackRef.source === Track2.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\nfunction sortScreenShareTracks(screenShareTracks) {\n  const localScreenShares = [];\n  const remoteScreenShares = [];\n  screenShareTracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\nfunction sortCameraTracks(cameraTrackReferences) {\n  const localCameraTracks = [];\n  const remoteCameraTracks = [];\n  cameraTrackReferences.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n  remoteCameraTracks.sort((a, b) => {\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n\n// src/sorting/sort-participants.ts\nimport { LocalParticipant as LocalParticipant2 } from \"livekit-client\";\nfunction sortParticipants(participants) {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n    const aVideo = a.videoTrackPublications.size > 0;\n    const bVideo = b.videoTrackPublications.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find(p => p instanceof LocalParticipant2);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n\n// src/helper/array-helper.ts\nfunction chunk(input, size) {\n  return input.reduce((arr, item, idx) => {\n    return idx % size === 0 ? [...arr, [item]] : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n  }, []);\n}\nfunction zip(a1, a2) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\nfunction differenceBy(a1, a2, by) {\n  return a1.filter(c => !a2.map(v => by(v)).includes(by(c)));\n}\n\n// src/track-reference/test-utils.ts\nimport { Participant, Track as Track3, TrackPublication } from \"livekit-client\";\nfunction flatTrackReferenceArray(list) {\n  return list.map(item => {\n    if (typeof item === \"string\" || typeof item === \"number\") {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n\n// src/sorting/tile-array-update.ts\nfunction visualPageChange(state, next) {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId)\n  };\n}\nfunction listNeedsUpdating(changes) {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\nfunction findIndex(trackReference, trackReferences) {\n  const indexToReplace = trackReferences.findIndex(trackReference_ => getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference));\n  if (indexToReplace === -1) {\n    throw new Error(`Element not part of the array: ${getTrackReferenceId(trackReference)} not in ${flatTrackReferenceArray(trackReferences)}`);\n  }\n  return indexToReplace;\n}\nfunction swapItems(moveForward, moveBack, trackReferences) {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n  return trackReferences;\n}\nfunction dropItem(itemToDrop, list) {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\nfunction addItem(itemToAdd, list) {\n  return [...list, itemToAdd];\n}\nfunction divideIntoPages(list, maxElementsOnPage) {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\nfunction updatePages(currentList, nextList, maxItemsOnPage) {\n  let updatedList = refreshList(currentList, nextList);\n  if (updatedList.length < nextList.length) {\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n      if (listNeedsUpdating(changes)) {\n        log.debug(`Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(currentPage)}, next: ${flatTrackReferenceArray(nextPage)}`, {\n          changes\n        });\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems(added, dropped, updatedList);\n            } else {\n              throw new Error(`For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`);\n            }\n          });\n        }\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach(item => {\n            updatedList = dropItem(item, updatedList);\n          });\n        }\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach(item => {\n            updatedList = addItem(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n  if (updatedList.length > nextList.length) {\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(item => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)));\n  }\n  return updatedList;\n}\nfunction refreshList(currentList, nextList) {\n  return currentList.map(currentItem => {\n    const updateForCurrentItem = nextList.find(newItem_ =>\n    // If the IDs match or ..\n    getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n    // ... if the current item is a placeholder and the new item is the track reference can replace it.\n    typeof currentItem !== \"number\" && isTrackReferencePlaceholder(currentItem) && isTrackReference(newItem_) && isPlaceholderReplacement(currentItem, newItem_));\n    return updateForCurrentItem != null ? updateForCurrentItem : currentItem;\n  });\n}\n\n// src/components/mediaToggle.ts\nimport { Track as Track7 } from \"livekit-client\";\nimport { Subject as Subject2, map as map4, startWith as startWith4 } from \"rxjs\";\n\n// src/observables/participant.ts\nimport { ParticipantEvent as ParticipantEvent2, RoomEvent as RoomEvent3, Track as Track6 } from \"livekit-client\";\nimport { Observable as Observable2, map as map3, startWith as startWith3, switchMap } from \"rxjs\";\n\n// src/components/mediaTrack.ts\nimport { Track as Track4 } from \"livekit-client\";\nimport { map, startWith } from \"rxjs\";\n\n// src/styles-interface/class-prefixer.ts\nfunction prefixClass(unprefixedClassName) {\n  return `${cssPrefix}-${unprefixedClassName}`;\n}\n\n// src/components/mediaTrack.ts\nfunction setupMediaTrack(trackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(map(() => {\n    return getTrackByIdentifier(trackIdentifier);\n  }), startWith(initialPub));\n  const className = prefixClass(trackIdentifier.source === Track4.Source.Camera || trackIdentifier.source === Track4.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\");\n  return {\n    className,\n    trackObserver\n  };\n}\nfunction getTrackByIdentifier(options) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const {\n      source,\n      name,\n      participant\n    } = options;\n    if (source && name) {\n      return participant.getTrackPublications().find(pub => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackPublicationByName(name);\n    } else if (source) {\n      return participant.getTrackPublication(source);\n    } else {\n      throw new Error(\"At least one of source and name needs to be defined\");\n    }\n  }\n}\n\n// src/observables/room.ts\nimport { Subject, map as map2, Observable, startWith as startWith2, finalize, filter, concat } from \"rxjs\";\nimport { LocalParticipant as LocalParticipant3, Room, RoomEvent as RoomEvent2, Track as Track5 } from \"livekit-client\";\nfunction observeRoomEvents(room, ...events) {\n  const observable = new Observable(subscribe => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n    events.forEach(evt => {\n      room.on(evt, onRoomUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith2(room));\n  return observable;\n}\nfunction roomEventSelector(room, event) {\n  const observable = new Observable(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    room.on(event, update);\n    const unsubscribe = () => {\n      room.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction roomObserver(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.ParticipantConnected, RoomEvent2.ParticipantDisconnected, RoomEvent2.ActiveSpeakersChanged, RoomEvent2.TrackSubscribed, RoomEvent2.TrackUnsubscribed, RoomEvent2.LocalTrackPublished, RoomEvent2.LocalTrackUnpublished, RoomEvent2.AudioPlaybackStatusChanged, RoomEvent2.ConnectionStateChanged).pipe(startWith2(room));\n  return observable;\n}\nfunction connectionStateObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ConnectionStateChanged).pipe(map2(([connectionState]) => connectionState), startWith2(room.state));\n}\nfunction screenShareObserver(room) {\n  let screenShareSubscriber;\n  const observers = [];\n  const observable = new Observable(subscriber => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach(observer => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks = [];\n  const handleSub = (publication, participant) => {\n    if (publication.source !== Track5.Source.ScreenShare && publication.source !== Track5.Source.ScreenShareAudio) {\n      return;\n    }\n    let trackMap = screenShareTracks.find(tr => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = participant2 => {\n      return participant2.getTrackPublications().filter(track => (track.source === Track5.Source.ScreenShare || track.source === Track5.Source.ScreenShareAudio) && track.track);\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant)\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(roomEventSelector(room, RoomEvent2.TrackSubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnsubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackPublished).subscribe(args => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackUnpublished).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackMuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnmuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  setTimeout(() => {\n    for (const p of room.remoteParticipants.values()) {\n      p.getTrackPublications().forEach(track => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n  return observable;\n}\nfunction roomInfoObserver(room) {\n  const observer = observeRoomEvents(room, RoomEvent2.RoomMetadataChanged, RoomEvent2.ConnectionStateChanged).pipe(map2(r => {\n    return {\n      name: r.name,\n      metadata: r.metadata\n    };\n  }));\n  return observer;\n}\nfunction activeSpeakerObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ActiveSpeakersChanged).pipe(map2(([speakers]) => speakers));\n}\nfunction createMediaDeviceObserver(kind, onError, requestPermissions = true) {\n  var _a;\n  const onDeviceChange = () => __async(this, null, function* () {\n    try {\n      const newDevices = yield Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e) {\n      onError == null ? void 0 : onError(e);\n    }\n  });\n  const deviceSubject = new Subject();\n  const observable = deviceSubject.pipe(finalize(() => {\n    var _a2;\n    (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.removeEventListener(\"devicechange\", onDeviceChange);\n  }));\n  if (typeof window !== \"undefined\") {\n    if (!window.isSecureContext) {\n      throw new Error(`Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`);\n    }\n    (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.addEventListener(\"devicechange\", onDeviceChange);\n  }\n  return concat(Room.getLocalDevices(kind, requestPermissions).catch(e => {\n    onError == null ? void 0 : onError(e);\n    return [];\n  }), observable);\n}\nfunction createDataObserver(room) {\n  return roomEventSelector(room, RoomEvent2.DataReceived);\n}\nfunction roomAudioPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.AudioPlaybackStatusChanged).pipe(map2(room2 => {\n    return {\n      canPlayAudio: room2.canPlaybackAudio\n    };\n  }));\n  return observable;\n}\nfunction roomVideoPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.VideoPlaybackStatusChanged).pipe(map2(room2 => {\n    return {\n      canPlayVideo: room2.canPlaybackVideo\n    };\n  }));\n  return observable;\n}\nfunction createActiveDeviceObservable(room, kind) {\n  return roomEventSelector(room, RoomEvent2.ActiveDeviceChanged).pipe(filter(([kindOfDevice]) => kindOfDevice === kind), map2(([kind2, deviceId]) => {\n    log.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", {\n      kind: kind2,\n      deviceId\n    });\n    return deviceId;\n  }), startWith2(room.getActiveDevice(kind)));\n}\nfunction encryptionStatusObservable(room, participant) {\n  return roomEventSelector(room, RoomEvent2.ParticipantEncryptionStatusChanged).pipe(filter(([, p]) => participant.identity === (p == null ? void 0 : p.identity) || !p && participant.identity === room.localParticipant.identity), map2(([encrypted]) => encrypted), startWith2(participant instanceof LocalParticipant3 ? participant.isE2EEEnabled : participant.isEncrypted));\n}\n\n// src/observables/participant.ts\nfunction observeParticipantEvents(participant, ...events) {\n  const observable = new Observable2(subscribe => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n    events.forEach(evt => {\n      participant.on(evt, onParticipantUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        participant.off(evt, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith3(participant));\n  return observable;\n}\nfunction observeParticipantMedia(participant) {\n  const participantObserver = observeParticipantEvents(participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.ParticipantPermissionsChanged,\n  // ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent2.TrackPublished, ParticipantEvent2.TrackUnpublished, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished, ParticipantEvent2.MediaDevicesError, ParticipantEvent2.TrackSubscriptionStatusChanged\n  // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(map3(p => {\n    const {\n      isMicrophoneEnabled,\n      isCameraEnabled,\n      isScreenShareEnabled\n    } = p;\n    const microphoneTrack = p.getTrackPublication(Track6.Source.Microphone);\n    const cameraTrack = p.getTrackPublication(Track6.Source.Camera);\n    const participantMedia = {\n      isCameraEnabled,\n      isMicrophoneEnabled,\n      isScreenShareEnabled,\n      cameraTrack,\n      microphoneTrack,\n      participant: p\n    };\n    return participantMedia;\n  }));\n  return participantObserver;\n}\nfunction createTrackObserver(participant, options) {\n  return observeParticipantMedia(participant).pipe(map3(() => {\n    return {\n      publication: getTrackByIdentifier(options)\n    };\n  }));\n}\nfunction participantInfoObserver(participant) {\n  const observer = observeParticipantEvents(participant, ParticipantEvent2.ParticipantMetadataChanged, ParticipantEvent2.ParticipantNameChanged).pipe(map3(({\n    name,\n    identity,\n    metadata\n  }) => {\n    return {\n      name,\n      identity,\n      metadata\n    };\n  }), startWith3({\n    name: participant.name,\n    identity: participant.identity,\n    metadata: participant.metadata\n  }));\n  return observer;\n}\nfunction createConnectionQualityObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ConnectionQualityChanged).pipe(map3(([quality]) => quality), startWith3(participant.connectionQuality));\n  return observer;\n}\nfunction participantEventSelector(participant, event) {\n  const observable = new Observable2(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    participant.on(event, update);\n    const unsubscribe = () => {\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction mutedObserver(trackRef) {\n  var _a, _b, _c, _d;\n  return observeParticipantEvents(trackRef.participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.TrackSubscribed, ParticipantEvent2.TrackUnsubscribed, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished).pipe(map3(participant => {\n    var _a2, _b2;\n    const pub = (_a2 = trackRef.publication) != null ? _a2 : participant.getTrackPublication(trackRef.source);\n    return (_b2 = pub == null ? void 0 : pub.isMuted) != null ? _b2 : true;\n  }), startWith3((_d = (_c = (_a = trackRef.publication) == null ? void 0 : _a.isMuted) != null ? _c : (_b = trackRef.participant.getTrackPublication(trackRef.source)) == null ? void 0 : _b.isMuted) != null ? _d : true));\n}\nfunction createIsSpeakingObserver(participant) {\n  return participantEventSelector(participant, ParticipantEvent2.IsSpeakingChanged).pipe(map3(([isSpeaking]) => isSpeaking));\n}\nfunction connectedParticipantsObserver(room, options = {}) {\n  var _a;\n  let subscriber;\n  const observable = new Observable2(sub => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith3(Array.from(room.remoteParticipants.values())));\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const roomEvents = Array.from( /* @__PURE__ */new Set([RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged, ...additionalRoomEvents]));\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(r => subscriber == null ? void 0 : subscriber.next(Array.from(r.remoteParticipants.values())));\n  if (room.remoteParticipants.size > 0) {\n    subscriber == null ? void 0 : subscriber.next(Array.from(room.remoteParticipants.values()));\n  }\n  return observable;\n}\nfunction connectedParticipantObserver(room, identity, options = {}) {\n  var _a;\n  const additionalEvents = (_a = options.additionalEvents) != null ? _a : allParticipantEvents;\n  const observable = observeRoomEvents(room, RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged).pipe(switchMap(r => {\n    const participant = r.getParticipantByIdentity(identity);\n    if (participant) {\n      return observeParticipantEvents(participant, ...additionalEvents);\n    } else {\n      return new Observable2(subscribe => subscribe.next(void 0));\n    }\n  }), startWith3(room.getParticipantByIdentity(identity)));\n  return observable;\n}\nfunction participantPermissionObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ParticipantPermissionsChanged).pipe(map3(() => participant.permissions), startWith3(participant.permissions));\n  return observer;\n}\nfunction participantByIdentifierObserver(room, {\n  kind,\n  identity\n}, options = {}) {\n  var _a;\n  const additionalEvents = (_a = options.additionalEvents) != null ? _a : allParticipantEvents;\n  const matchesIdentifier = participant => {\n    let isMatch = true;\n    if (kind) {\n      isMatch = isMatch && participant.kind === kind;\n    }\n    if (identity) {\n      isMatch = isMatch && participant.identity === identity;\n    }\n    return isMatch;\n  };\n  const observable = observeRoomEvents(room, RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged).pipe(switchMap(r => {\n    const participant = Array.from(r.remoteParticipants.values()).find(p => matchesIdentifier(p));\n    if (participant) {\n      return observeParticipantEvents(participant, ...additionalEvents);\n    } else {\n      return new Observable2(subscribe => subscribe.next(void 0));\n    }\n  }), startWith3(Array.from(room.remoteParticipants.values()).find(p => matchesIdentifier(p))));\n  return observable;\n}\n\n// src/components/mediaToggle.ts\nfunction setupMediaToggle(source, room, options, publishOptions, onError) {\n  const {\n    localParticipant\n  } = room;\n  const getSourceEnabled = (source2, localParticipant2) => {\n    let isEnabled = false;\n    switch (source2) {\n      case Track7.Source.Camera:\n        isEnabled = localParticipant2.isCameraEnabled;\n        break;\n      case Track7.Source.Microphone:\n        isEnabled = localParticipant2.isMicrophoneEnabled;\n        break;\n      case Track7.Source.ScreenShare:\n        isEnabled = localParticipant2.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(map4(media => {\n    return getSourceEnabled(source, media.participant);\n  }), startWith4(getSourceEnabled(source, localParticipant)));\n  const pendingSubject = new Subject2();\n  const toggle = (forceState, captureOptions) => __async(this, null, function* () {\n    try {\n      captureOptions != null ? captureOptions : captureOptions = options;\n      pendingSubject.next(true);\n      switch (source) {\n        case Track7.Source.Camera:\n          yield localParticipant.setCameraEnabled(forceState != null ? forceState : !localParticipant.isCameraEnabled, captureOptions, publishOptions);\n          break;\n        case Track7.Source.Microphone:\n          yield localParticipant.setMicrophoneEnabled(forceState != null ? forceState : !localParticipant.isMicrophoneEnabled, captureOptions, publishOptions);\n          break;\n        case Track7.Source.ScreenShare:\n          yield localParticipant.setScreenShareEnabled(forceState != null ? forceState : !localParticipant.isScreenShareEnabled, captureOptions, publishOptions);\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (onError && e instanceof Error) {\n        onError == null ? void 0 : onError(e);\n      } else {\n        throw e;\n      }\n    } finally {\n      pendingSubject.next(false);\n    }\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\nfunction setupManualToggle() {\n  let state = false;\n  const enabledSubject = new Subject2();\n  const pendingSubject = new Subject2();\n  const toggle = forceState => __async(this, null, function* () {\n    pendingSubject.next(true);\n    state = forceState != null ? forceState : !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\n\n// src/components/mediaDeviceSelect.ts\nimport { Track as Track8 } from \"livekit-client\";\nimport { BehaviorSubject } from \"rxjs\";\nfunction setupDeviceSelector(kind, room, localTrack) {\n  const activeDeviceSubject = new BehaviorSubject(void 0);\n  const activeDeviceObservable = room ? createActiveDeviceObservable(room, kind) : activeDeviceSubject.asObservable();\n  const setActiveMediaDevice = (_0, ..._1) => __async(this, [_0, ..._1], function* (id, options = {}) {\n    var _a, _b, _c;\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      yield room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId = (_a = room.getActiveDevice(kind)) != null ? _a : id;\n      if (actualDeviceId !== id && id !== \"default\") {\n        log.info(`We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`);\n      }\n      let targetTrack = void 0;\n      if (kind === \"audioinput\") targetTrack = (_b = room.localParticipant.getTrackPublication(Track8.Source.Microphone)) == null ? void 0 : _b.track;else if (kind === \"videoinput\") {\n        targetTrack = (_c = room.localParticipant.getTrackPublication(Track8.Source.Camera)) == null ? void 0 : _c.track;\n      }\n      const useDefault = id === \"default\" && !targetTrack || id === \"default\" && (targetTrack == null ? void 0 : targetTrack.mediaStreamTrack.label.startsWith(\"Default\"));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      yield localTrack.setDeviceId(options.exact ? {\n        exact: id\n      } : id);\n      const actualId = yield localTrack.getDeviceId();\n      activeDeviceSubject.next(id === \"default\" && localTrack.mediaStreamTrack.label.startsWith(\"Default\") ? id : actualId);\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\"device switch skipped, please provide either a room or a local track to switch on. \");\n      activeDeviceSubject.next(id);\n    }\n  });\n  const className = prefixClass(\"media-device-select\");\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice\n  };\n}\n\n// src/components/disconnectButton.ts\nfunction setupDisconnectButton(room) {\n  const disconnect = stopTracks => {\n    room.disconnect(stopTracks);\n  };\n  const className = prefixClass(\"disconnect-button\");\n  return {\n    className,\n    disconnect\n  };\n}\n\n// src/components/connectionQualityIndicator.ts\nfunction setupConnectionQualityIndicator(participant) {\n  const className = prefixClass(\"connection-quality\");\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return {\n    className,\n    connectionQualityObserver\n  };\n}\n\n// src/components/trackMutedIndicator.ts\nimport { Track as Track9 } from \"livekit-client\";\nfunction setupTrackMutedIndicator(trackRef) {\n  let classForSource = \"track-muted-indicator-camera\";\n  switch (trackRef.source) {\n    case Track9.Source.Camera:\n      classForSource = \"track-muted-indicator-camera\";\n      break;\n    case Track9.Source.Microphone:\n      classForSource = \"track-muted-indicator-microphone\";\n      break;\n    default:\n      break;\n  }\n  const className = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n  return {\n    className,\n    mediaMutedObserver\n  };\n}\n\n// src/components/participantName.ts\nfunction setupParticipantName(participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return {\n    className: \"lk-participant-name\",\n    infoObserver\n  };\n}\n\n// src/components/participantTile.ts\nfunction setupParticipantTile() {\n  const className = prefixClass(\"participant-tile\");\n  return {\n    className\n  };\n}\n\n// src/components/chat.ts\nimport { RoomEvent as RoomEvent4 } from \"livekit-client\";\nimport { BehaviorSubject as BehaviorSubject2, Subject as Subject3, scan, map as map6, takeUntil } from \"rxjs\";\n\n// src/observables/dataChannel.ts\nimport { Observable as Observable3, filter as filter2, map as map5 } from \"rxjs\";\nvar DataTopic = {\n  CHAT: \"lk-chat-topic\",\n  CHAT_UPDATE: \"lk-chat-update-topic\"\n};\nfunction sendMessage(_0, _1) {\n  return __async(this, arguments, function* (localParticipant, payload, options = {}) {\n    const {\n      reliable,\n      destinationIdentities,\n      topic\n    } = options;\n    yield localParticipant.publishData(payload, {\n      destinationIdentities,\n      topic,\n      reliable\n    });\n  });\n}\nfunction setupDataMessageHandler(room, topic, onMessage) {\n  const topics = Array.isArray(topic) ? topic : [topic];\n  const messageObservable = createDataObserver(room).pipe(filter2(([,,, messageTopic]) => topic === void 0 || messageTopic !== void 0 && topics.includes(messageTopic)), map5(([payload, participant,, messageTopic]) => {\n    const msg = {\n      payload,\n      topic: messageTopic,\n      from: participant\n    };\n    onMessage == null ? void 0 : onMessage(msg);\n    return msg;\n  }));\n  let isSendingSubscriber;\n  const isSendingObservable = new Observable3(subscriber => {\n    isSendingSubscriber = subscriber;\n  });\n  const send = (_0, ..._1) => __async(this, [_0, ..._1], function* (payload, options = {}) {\n    isSendingSubscriber.next(true);\n    try {\n      yield sendMessage(room.localParticipant, payload, __spreadValues({\n        topic: topics[0]\n      }, options));\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  });\n  return {\n    messageObservable,\n    isSendingObservable,\n    send\n  };\n}\n\n// src/components/chat.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar topicSubjectMap = /* @__PURE__ */new Map();\nvar encode = message => encoder.encode(JSON.stringify(message));\nvar decode = message => JSON.parse(decoder.decode(message));\nfunction setupChat(room, options) {\n  var _a, _b;\n  const onDestroyObservable = new Subject3();\n  const {\n    messageDecoder,\n    messageEncoder,\n    channelTopic,\n    updateChannelTopic\n  } = options != null ? options : {};\n  const topic = channelTopic != null ? channelTopic : DataTopic.CHAT;\n  const updateTopic = updateChannelTopic != null ? updateChannelTopic : DataTopic.CHAT_UPDATE;\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = (_a = topicSubjectMap.get(room)) != null ? _a : /* @__PURE__ */new Map();\n  const messageSubject = (_b = topicMap.get(topic)) != null ? _b : new Subject3();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n  if (needsSetup) {\n    const {\n      messageObservable\n    } = setupDataMessageHandler(room, [topic, updateTopic]);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n  const finalMessageDecoder = messageDecoder != null ? messageDecoder : decode;\n  const messagesObservable = messageSubject.pipe(map6(msg => {\n    const parsedMessage = finalMessageDecoder(msg.payload);\n    const newMessage = __spreadProps(__spreadValues({}, parsedMessage), {\n      from: msg.from\n    });\n    return newMessage;\n  }), scan((acc, value) => {\n    if (\"id\" in value && acc.find(msg => {\n      var _a2, _b2;\n      return ((_a2 = msg.from) == null ? void 0 : _a2.identity) === ((_b2 = value.from) == null ? void 0 : _b2.identity) && msg.id === value.id;\n    })) {\n      const replaceIndex = acc.findIndex(msg => msg.id === value.id);\n      if (replaceIndex > -1) {\n        const originalMsg = acc[replaceIndex];\n        acc[replaceIndex] = __spreadProps(__spreadValues({}, value), {\n          timestamp: originalMsg.timestamp,\n          editTimestamp: value.timestamp\n        });\n      }\n      return [...acc];\n    }\n    return [...acc, value];\n  }, []), takeUntil(onDestroyObservable));\n  const isSending$ = new BehaviorSubject2(false);\n  const finalMessageEncoder = messageEncoder != null ? messageEncoder : encode;\n  const send = message => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const id = crypto.randomUUID();\n    const chatMessage = {\n      id,\n      message,\n      timestamp\n    };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, {\n        reliable: true,\n        topic\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  const update = (message, messageId) => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const chatMessage = {\n      id: messageId,\n      message,\n      timestamp\n    };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, {\n        topic: updateTopic,\n        reliable: true\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.delete(room);\n  }\n  room.once(RoomEvent4.Disconnected, destroy);\n  return {\n    messageObservable: messagesObservable,\n    isSendingObservable: isSending$,\n    send,\n    update\n  };\n}\n\n// src/components/startAudio.ts\nfunction setupStartAudio() {\n  const handleStartAudioPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Audio for room: \", room);\n    yield room.startAudio();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomAudioPlaybackAllowedObservable,\n    handleStartAudioPlayback\n  };\n}\n\n// src/components/startVideo.ts\nfunction setupStartVideo() {\n  const handleStartVideoPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Video for room: \", room);\n    yield room.startVideo();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomVideoPlaybackAllowedObservable,\n    handleStartVideoPlayback\n  };\n}\n\n// src/components/chatToggle.ts\nfunction setupChatToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"chat-toggle\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/focusToggle.ts\nfunction setupFocusToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"focus-toggle-button\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/clearPinButton.ts\nfunction setupClearPinButton() {\n  const className = \"lk-clear-pin-button lk-button\";\n  return {\n    className\n  };\n}\n\n// src/components/room.ts\nfunction setupLiveKitRoom() {\n  const className = \"lk-room-container\";\n  return {\n    className\n  };\n}\n\n// src/observables/track.ts\nimport { RoomEvent as RoomEvent5, TrackEvent } from \"livekit-client\";\nimport { map as map7, Observable as Observable4, startWith as startWith5 } from \"rxjs\";\nfunction trackObservable(track) {\n  const trackObserver = observeTrackEvents(track, TrackEvent.Muted, TrackEvent.Unmuted, TrackEvent.Subscribed, TrackEvent.Unsubscribed);\n  return trackObserver;\n}\nfunction observeTrackEvents(track, ...events) {\n  const observable = new Observable4(subscribe => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n    events.forEach(evt => {\n      track.on(evt, onTrackUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith5(track));\n  return observable;\n}\nfunction getTrackReferences(room, sources, onlySubscribedTracks = true) {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.remoteParticipants.values())];\n  const trackReferences = [];\n  allParticipants.forEach(participant => {\n    sources.forEach(source => {\n      const sourceReferences = Array.from(participant.trackPublications.values()).filter(track => track.source === source && (\n      // either return all or only the ones that are subscribed\n      !onlySubscribedTracks || track.track)).map(track => {\n        return {\n          participant,\n          publication: track,\n          source: track.source\n        };\n      });\n      trackReferences.push(...sourceReferences);\n    });\n  });\n  return {\n    trackReferences,\n    participants: allParticipants\n  };\n}\nfunction getParticipantTrackRefs(participant, identifier, onlySubscribedTracks = false) {\n  const {\n    sources,\n    kind,\n    name\n  } = identifier;\n  const sourceReferences = Array.from(participant.trackPublications.values()).filter(pub => (!sources || sources.includes(pub.source)) && (!kind || pub.kind === kind) && (!name || pub.trackName === name) && (\n  // either return all or only the ones that are subscribed\n  !onlySubscribedTracks || pub.track)).map(track => {\n    return {\n      participant,\n      publication: track,\n      source: track.source\n    };\n  });\n  return sourceReferences;\n}\nfunction trackReferencesObservable(room, sources, options) {\n  var _a, _b;\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const onlySubscribedTracks = (_b = options.onlySubscribed) != null ? _b : true;\n  const roomEvents = Array.from(( /* @__PURE__ */new Set([RoomEvent5.ParticipantConnected, RoomEvent5.ParticipantDisconnected, RoomEvent5.ConnectionStateChanged, RoomEvent5.LocalTrackPublished, RoomEvent5.LocalTrackUnpublished, RoomEvent5.TrackPublished, RoomEvent5.TrackUnpublished, RoomEvent5.TrackSubscriptionStatusChanged, ...additionalRoomEvents])).values());\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(map7(room2 => {\n    const data = getTrackReferences(room2, sources, onlySubscribedTracks);\n    log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n    return data;\n  }), startWith5(getTrackReferences(room, sources, onlySubscribedTracks)));\n  return observable;\n}\nfunction participantTracksObservable(participant, trackIdentifier) {\n  const observable = observeParticipantEvents(participant, ...participantTrackEvents).pipe(map7(participant2 => {\n    const data = getParticipantTrackRefs(participant2, trackIdentifier);\n    log.debug(`TrackReference[] was updated. (length ${data.length})`, data);\n    return data;\n  }), startWith5(getParticipantTrackRefs(participant, trackIdentifier)));\n  return observable;\n}\nfunction trackEventSelector(publication, event) {\n  const observable = new Observable4(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    publication.on(event, update);\n    const unsubscribe = () => {\n      publication.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction trackTranscriptionObserver(publication) {\n  return trackEventSelector(publication, TrackEvent.TranscriptionReceived);\n}\nfunction trackSyncTimeObserver(track) {\n  return trackEventSelector(track, TrackEvent.TimeSyncUpdate).pipe(map7(([timeUpdate]) => timeUpdate));\n}\n\n// src/observables/dom-event.ts\nimport { concat as concat2, distinctUntilChanged, fromEvent, map as map8, of, skipUntil, timeout } from \"rxjs\";\nfunction createInteractingObservable(htmlElement, inactiveAfter = 1e3) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, \"mousemove\", {\n    passive: true\n  }).pipe(map8(() => true));\n  const moveAndStop$ = move$.pipe(timeout({\n    each: inactiveAfter,\n    with: () => concat2(of(false), moveAndStop$.pipe(skipUntil(move$)))\n  }), distinctUntilChanged());\n  return moveAndStop$;\n}\n\n// src/persistent-storage/local-storage-helpers.ts\nfunction saveToLocalStorage(key, value) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\nfunction loadFromLocalStorage(key) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return void 0;\n  }\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return void 0;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return void 0;\n  }\n}\nfunction createLocalStorageInterface(key) {\n  return {\n    load: () => loadFromLocalStorage(key),\n    save: value => saveToLocalStorage(key, value)\n  };\n}\n\n// src/persistent-storage/user-choices.ts\nvar USER_CHOICES_KEY = `${cssPrefix}-user-choices`;\nvar defaultUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: \"\",\n  audioDeviceId: \"\",\n  username: \"\"\n};\nvar {\n  load,\n  save\n} = createLocalStorageInterface(USER_CHOICES_KEY);\nfunction saveUserChoices(userChoices, preventSave = false) {\n  if (preventSave === true) {\n    return;\n  }\n  save(userChoices);\n}\nfunction loadUserChoices(defaults, preventLoad = false) {\n  var _a, _b, _c, _d, _e;\n  const fallback = {\n    videoEnabled: (_a = defaults == null ? void 0 : defaults.videoEnabled) != null ? _a : defaultUserChoices.videoEnabled,\n    audioEnabled: (_b = defaults == null ? void 0 : defaults.audioEnabled) != null ? _b : defaultUserChoices.audioEnabled,\n    videoDeviceId: (_c = defaults == null ? void 0 : defaults.videoDeviceId) != null ? _c : defaultUserChoices.videoDeviceId,\n    audioDeviceId: (_d = defaults == null ? void 0 : defaults.audioDeviceId) != null ? _d : defaultUserChoices.audioDeviceId,\n    username: (_e = defaults == null ? void 0 : defaults.username) != null ? _e : defaultUserChoices.username\n  };\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = __spreadValues(__spreadValues({}, fallback), maybeLoadedObject != null ? maybeLoadedObject : {});\n    return result;\n  }\n}\nexport { DataTopic, GRID_LAYOUTS, PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE, activeSpeakerObserver, addMediaTimestampToTranscription, allParticipantEvents, allParticipantRoomEvents, allRemoteParticipantEvents, allRemoteParticipantRoomEvents, attachIfSubscribed, computeMenuPosition, connectedParticipantObserver, connectedParticipantsObserver, connectionStateObserver, createActiveDeviceObservable, createConnectionQualityObserver, createDataObserver, createDefaultGrammar, createEmailRegExp, createInteractingObservable, createIsSpeakingObserver, createMediaDeviceObserver, createTrackObserver, createUrlRegExp, cssPrefix, dedupeSegments, defaultUserChoices, didActiveSegmentsChange, encryptionStatusObservable, getActiveTranscriptionSegments, getScrollBarWidth, getTrackByIdentifier, getTrackReferenceId, getTrackReferenceSource, isEqualTrackRef, isLocal, isMobileBrowser, isParticipantTrackReferencePinned, isPlaceholderReplacement, isRemote, isSourceWitOptions, isSourcesWithOptions, isTrackReference, isTrackReferencePinned, isTrackReferencePlaceholder, isWeb, loadUserChoices, log, mutedObserver, observeParticipantEvents, observeParticipantMedia, observeRoomEvents, observeTrackEvents, participantByIdentifierObserver, participantEventSelector, participantInfoObserver, participantPermissionObserver, participantTrackEvents, participantTracksObservable, roomAudioPlaybackAllowedObservable, roomEventSelector, roomInfoObserver, roomObserver, roomVideoPlaybackAllowedObservable, saveUserChoices, screenShareObserver, selectGridLayout, sendMessage, setDifference, setLogExtension, setLogLevel, setupChat, setupChatToggle, setupClearPinButton, setupConnectionQualityIndicator, setupDataMessageHandler, setupDeviceSelector, setupDisconnectButton, setupFocusToggle, setupLiveKitRoom, setupManualToggle, setupMediaToggle, setupMediaTrack, setupParticipantName, setupParticipantTile, setupStartAudio, setupStartVideo, setupTrackMutedIndicator, sortParticipants, sortTrackReferences, supportsScreenSharing, tokenize, trackEventSelector, trackObservable, trackReferencesObservable, trackSyncTimeObserver, trackTranscriptionObserver, updatePages, wasClickOutside };","map":{"version":3,"names":["cssPrefix","LocalParticipant","RemoteParticipant","isTrackReference","trackReference","isTrackReferenceSubscribed","isTrackReferencePublished","_a","hasOwnProperty","publication","track","isTrackReferencePlaceholder","getTrackReferenceId","participant","identity","source","trackSid","Error","getTrackReferenceSource","isEqualTrackRef","a","b","isTrackReferencePinned","pinState","some","pinnedTrackReference","isPlaceholderReplacement","currentTrackRef","nextTrackRef","isLocal","p","isRemote","attachIfSubscribed","element","isSubscribed","attach","detach","isParticipantTrackReferencePinned","trackRef","pinnedTrackRef","getScrollBarWidth","inner","document","createElement","style","width","height","outer","position","top","left","visibility","overflow","appendChild","body","w1","offsetWidth","w2","clientWidth","removeChild","scrollBarWidth","isWeb","isMobileBrowser","test","window","navigator","userAgent","createUrlRegExp","options","__spreadValues","protocol","auth","ip","RegExp","host","domain","tld","port","path","regex2","exact","regex","createEmailRegExp","computePosition","flip","offset","shift","computeMenuPosition","button","menu","__async","x","y","placement","middleware","padding","wasClickOutside","insideElement","event","isOutside","contains","target","createDefaultGrammar","email","url","tokenize","input","grammar","matches","Object","entries","map","type","rx","weight","Array","from","matchAll","index","content","flat","sort","d","filter","i","arr","prev","length","tokens","pos","push","substring","ParticipantEvent","RoomEvent","allRemoteParticipantRoomEvents","ConnectionStateChanged","RoomMetadataChanged","ActiveSpeakersChanged","ConnectionQualityChanged","ParticipantConnected","ParticipantDisconnected","ParticipantPermissionsChanged","ParticipantMetadataChanged","TrackMuted","TrackUnmuted","TrackPublished","TrackUnpublished","TrackStreamStateChanged","TrackSubscriptionFailed","TrackSubscriptionPermissionChanged","TrackSubscriptionStatusChanged","allParticipantRoomEvents","LocalTrackPublished","LocalTrackUnpublished","participantTrackEvents","TrackSubscribed","TrackUnsubscribed","allRemoteParticipantEvents","IsSpeakingChanged","allParticipantEvents","setLogLevel","setClientSdkLogLevel","setLogExtension","setClientSdkLogExtension","LogLevel","LogLevelEnum","loglevel","log","getLogger","setDefaultLevel","level","setLevel","liveKitClientLogLevel","extension","originalFactory","methodFactory","methodName","configLevel","loggerName","rawMethod","logLevel","needLog","silent","msg","context","getLevel","liveKitClientLogExtension","GRID_LAYOUTS","columns","rows","name","minTiles","maxTiles","minWidth","minHeight","selectGridLayout","layouts","participantCount","currentLayoutIndex","layout","find","layout_","allLayouts","isBiggerLayoutAvailable","findIndex","l","layoutIsBiggerThanCurrent","layoutFitsSameAmountOfParticipants","warn","smallerLayout","slice","setDifference","setA","setB","_difference","Set","elem","delete","supportsScreenSharing","mediaDevices","getDisplayMedia","getActiveTranscriptionSegments","segments","syncTimes","maxAge","segment","hasTrackSync","rtpTimestamp","currentTrackTime","performance","timeOrigin","now","displayStartTime","Math","max","receivedAtMediaTimestamp","startTime","receivedAt","segmentDuration","endTime","addMediaTimestampToTranscription","timestamps","__spreadProps","timestamp","dedupeSegments","prevSegments","newSegments","windowSize","reduceRight","acc","val","id","unshift","didActiveSegmentsChange","prevActive","newActive","every","newSegment","prevSegment","text","final","language","PIN_DEFAULT_STATE","WIDGET_DEFAULT_STATE","showChat","unreadMessages","showSettings","isSourceWitOptions","isSourcesWithOptions","sources","isArray","Track","Track2","sortParticipantsByAudioLevel","audioLevel","sortParticipantsByIsSpeaking","isSpeaking","sortParticipantsByLastSpokenAT","_b","_c","_d","lastSpokeAt","getTime","sortParticipantsByJoinedAt","joinedAt","sortTrackReferencesByType","sortTrackRefsByIsCameraEnabled","aVideo","isCameraEnabled","bVideo","sortTrackReferences","tracks","localTracks","screenShareTracks","cameraTracks","undefinedTracks","forEach","Source","Camera","ScreenShare","sortedScreenShareTracks","sortScreenShareTracks","sortedCameraTracks","sortCameraTracks","localScreenShares","remoteScreenShares","sortedScreenShareTrackRefs","cameraTrackReferences","localCameraTracks","remoteCameraTracks","LocalParticipant2","sortParticipants","participants","sortedParticipants","videoTrackPublications","size","localParticipant","localIdx","indexOf","splice","chunk","reduce","item","idx","zip","a1","a2","resultLength","fill","_val","differenceBy","by","c","v","includes","Participant","Track3","TrackPublication","flatTrackReferenceArray","list","visualPageChange","state","next","dropped","added","listNeedsUpdating","changes","trackReferences","indexToReplace","trackReference_","swapItems","moveForward","moveBack","indexReplaceWith","dropItem","itemToDrop","indexOfElementToDrop","addItem","itemToAdd","divideIntoPages","maxElementsOnPage","pages","updatePages","currentList","nextList","maxItemsOnPage","updatedList","refreshList","addedItems","currentPages","nextPages","currentPage","nextPage","pageIndex","updatedPage","debug","missingItems","currentItem","updateForCurrentItem","newItem_","Track7","Subject","Subject2","map4","startWith","startWith4","ParticipantEvent2","RoomEvent3","Track6","Observable","Observable2","map3","startWith3","switchMap","Track4","prefixClass","unprefixedClassName","setupMediaTrack","trackIdentifier","initialPub","getTrackByIdentifier","trackObserver","observeParticipantMedia","pipe","className","getTrackPublications","pub","trackName","getTrackPublicationByName","getTrackPublication","map2","startWith2","finalize","concat","LocalParticipant3","Room","RoomEvent2","Track5","observeRoomEvents","room","events","observable","subscribe","onRoomUpdate","evt","on","unsubscribe","off","roomEventSelector","update","params","roomObserver","AudioPlaybackStatusChanged","connectionStateObserver","connectionState","screenShareObserver","screenShareSubscriber","observers","subscriber","observer","handleSub","ScreenShareAudio","trackMap","tr","getScreenShareTracks","participant2","args","setTimeout","remoteParticipants","values","roomInfoObserver","r","metadata","activeSpeakerObserver","speakers","createMediaDeviceObserver","kind","onError","requestPermissions","onDeviceChange","newDevices","getLocalDevices","deviceSubject","e","_a2","removeEventListener","isSecureContext","addEventListener","catch","createDataObserver","DataReceived","roomAudioPlaybackAllowedObservable","room2","canPlayAudio","canPlaybackAudio","roomVideoPlaybackAllowedObservable","VideoPlaybackStatusChanged","canPlayVideo","canPlaybackVideo","createActiveDeviceObservable","ActiveDeviceChanged","kindOfDevice","kind2","deviceId","getActiveDevice","encryptionStatusObservable","ParticipantEncryptionStatusChanged","encrypted","isE2EEEnabled","isEncrypted","observeParticipantEvents","onParticipantUpdate","participantObserver","MediaDevicesError","isMicrophoneEnabled","isScreenShareEnabled","microphoneTrack","Microphone","cameraTrack","participantMedia","createTrackObserver","participantInfoObserver","ParticipantNameChanged","createConnectionQualityObserver","participantEventSelector","quality","connectionQuality","mutedObserver","_b2","isMuted","createIsSpeakingObserver","connectedParticipantsObserver","sub","listener","additionalRoomEvents","roomEvents","connectedParticipantObserver","additionalEvents","getParticipantByIdentity","participantPermissionObserver","permissions","participantByIdentifierObserver","matchesIdentifier","isMatch","setupMediaToggle","publishOptions","getSourceEnabled","source2","localParticipant2","isEnabled","enabledObserver","media","pendingSubject","toggle","forceState","captureOptions","setCameraEnabled","setMicrophoneEnabled","setScreenShareEnabled","pendingObserver","asObservable","setupManualToggle","enabledSubject","Track8","BehaviorSubject","setupDeviceSelector","localTrack","activeDeviceSubject","activeDeviceObservable","setActiveMediaDevice","_0","_1","switchActiveDevice","actualDeviceId","info","targetTrack","useDefault","mediaStreamTrack","label","startsWith","setDeviceId","actualId","getDeviceId","value","setupDisconnectButton","disconnect","stopTracks","setupConnectionQualityIndicator","connectionQualityObserver","Track9","setupTrackMutedIndicator","classForSource","mediaMutedObserver","setupParticipantName","infoObserver","setupParticipantTile","RoomEvent4","BehaviorSubject2","Subject3","scan","map6","takeUntil","Observable3","filter2","map5","DataTopic","CHAT","CHAT_UPDATE","sendMessage","arguments","payload","reliable","destinationIdentities","topic","publishData","setupDataMessageHandler","onMessage","topics","messageObservable","messageTopic","isSendingSubscriber","isSendingObservable","send","encoder","TextEncoder","decoder","TextDecoder","topicSubjectMap","Map","encode","message","JSON","stringify","decode","parse","setupChat","onDestroyObservable","messageDecoder","messageEncoder","channelTopic","updateChannelTopic","updateTopic","needsSetup","has","topicMap","get","messageSubject","set","finalMessageDecoder","messagesObservable","parsedMessage","newMessage","replaceIndex","originalMsg","editTimestamp","isSending$","finalMessageEncoder","Date","crypto","randomUUID","chatMessage","encodedMsg","messageId","destroy","complete","once","Disconnected","setupStartAudio","handleStartAudioPlayback","startAudio","setupStartVideo","handleStartVideoPlayback","startVideo","setupChatToggle","join","setupFocusToggle","setupClearPinButton","setupLiveKitRoom","RoomEvent5","TrackEvent","map7","Observable4","startWith5","trackObservable","observeTrackEvents","Muted","Unmuted","Subscribed","Unsubscribed","onTrackUpdate","getTrackReferences","onlySubscribedTracks","allParticipants","sourceReferences","trackPublications","getParticipantTrackRefs","identifier","trackReferencesObservable","onlySubscribed","data","participantTracksObservable","trackEventSelector","trackTranscriptionObserver","TranscriptionReceived","trackSyncTimeObserver","TimeSyncUpdate","timeUpdate","concat2","distinctUntilChanged","fromEvent","map8","of","skipUntil","timeout","createInteractingObservable","htmlElement","inactiveAfter","move$","passive","moveAndStop$","each","with","saveToLocalStorage","key","localStorage","error","setItem","loadFromLocalStorage","getItem","createLocalStorageInterface","load","save","USER_CHOICES_KEY","defaultUserChoices","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","username","saveUserChoices","userChoices","preventSave","loadUserChoices","defaults","preventLoad","_e","fallback","maybeLoadedObject","result"],"sources":["/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/constants.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/utils.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/track-reference/track-reference.types.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/track-reference/track-reference.utils.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/detectMobileBrowser.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/url-regex.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/emailRegex.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/floating-menu.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/tokenizer.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/eventGroups.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/logger.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/grid-layouts.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/set-helper.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/featureDetection.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/transcriptions.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/types.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/sorting/sort-track-bundles.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/sorting/base-sort-functions.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/sorting/sort-participants.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/helper/array-helper.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/track-reference/test-utils.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/sorting/tile-array-update.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/mediaToggle.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/observables/participant.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/mediaTrack.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/styles-interface/class-prefixer.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/observables/room.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/mediaDeviceSelect.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/disconnectButton.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/connectionQualityIndicator.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/trackMutedIndicator.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/participantName.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/participantTile.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/chat.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/observables/dataChannel.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/startAudio.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/startVideo.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/chatToggle.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/focusToggle.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/clearPinButton.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/components/room.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/observables/track.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/observables/dom-event.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/persistent-storage/local-storage-helpers.ts","/home/nishanth/projects/livekit-demo/node_modules/@livekit/components-core/src/persistent-storage/user-choices.ts"],"sourcesContent":["export const cssPrefix = 'lk';\n","import type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, RemoteParticipant } from 'livekit-client';\n\nimport type { PinState } from './types';\nimport type { TrackReference } from './track-reference';\nimport { isEqualTrackRef } from './track-reference';\n\nexport function isLocal(p: Participant) {\n  return p instanceof LocalParticipant;\n}\n\nexport function isRemote(p: Participant) {\n  return p instanceof RemoteParticipant;\n}\n\nexport const attachIfSubscribed = (\n  publication: TrackPublication | undefined,\n  element: HTMLMediaElement | null | undefined,\n) => {\n  if (!publication) return;\n  const { isSubscribed, track } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\n\n/**\n * Check if the participant track reference is pinned.\n */\nexport function isParticipantTrackReferencePinned(\n  trackRef: TrackReference,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some((pinnedTrackRef) => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\n\n/**\n * Calculates the scrollbar width by creating two HTML elements\n * and messaging the difference.\n * @internal\n */\nexport function getScrollBarWidth() {\n  const inner = document.createElement('p');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.left = '0px';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '200px';\n  outer.style.height = '150px';\n  outer.style.overflow = 'hidden';\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n","/**\n * The TrackReference type is a logical grouping of participant publication and/or subscribed track.\n *\n */\n\nimport type { Participant, Track, TrackPublication } from 'livekit-client';\n// ## TrackReference Types\n\n/** @public */\nexport type TrackReferencePlaceholder = {\n  participant: Participant;\n  publication?: never;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReference = {\n  participant: Participant;\n  publication: TrackPublication;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReferenceOrPlaceholder = TrackReference | TrackReferencePlaceholder;\n\n// ### TrackReference Type Predicates\n/** @internal */\nexport function isTrackReference(trackReference: unknown): trackReference is TrackReference {\n  if (typeof trackReference === 'undefined') {\n    return false;\n  }\n  return (\n    isTrackReferenceSubscribed(trackReference as TrackReference) ||\n    isTrackReferencePublished(trackReference as TrackReference)\n  );\n}\n\nfunction isTrackReferenceSubscribed(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('track') &&\n    typeof trackReference.publication?.track !== 'undefined'\n  );\n}\n\nfunction isTrackReferencePublished(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('publication') &&\n    typeof trackReference.publication !== 'undefined'\n  );\n}\n\nexport function isTrackReferencePlaceholder(\n  trackReference?: TrackReferenceOrPlaceholder,\n): trackReference is TrackReferencePlaceholder {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    typeof trackReference.publication === 'undefined'\n  );\n}\n","import type { Track } from 'livekit-client';\nimport type { PinState } from '../types';\nimport type { TrackReferenceOrPlaceholder } from './track-reference.types';\nimport { isTrackReference, isTrackReferencePlaceholder } from './track-reference.types';\n\n/**\n * Returns a id to identify the `TrackReference` or `TrackReferencePlaceholder` based on\n * participant, track source and trackSid.\n * @remarks\n * The id pattern is: `${participantIdentity}_${trackSource}_${trackSid}` for `TrackReference`\n * and `${participantIdentity}_${trackSource}_placeholder` for `TrackReferencePlaceholder`.\n */\nexport function getTrackReferenceId(trackReference: TrackReferenceOrPlaceholder | number) {\n  if (typeof trackReference === 'string' || typeof trackReference === 'number') {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\n\nexport type TrackReferenceId = ReturnType<typeof getTrackReferenceId>;\n\n/** Returns the Source of the TrackReference. */\nexport function getTrackReferenceSource(trackReference: TrackReferenceOrPlaceholder): Track.Source {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\n\nexport function isEqualTrackRef(\n  a?: TrackReferenceOrPlaceholder,\n  b?: TrackReferenceOrPlaceholder,\n): boolean {\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\n\n/**\n * Check if the `TrackReference` is pinned.\n */\nexport function isTrackReferencePinned(\n  trackReference: TrackReferenceOrPlaceholder,\n  pinState: PinState | undefined,\n): boolean {\n  if (typeof pinState === 'undefined') {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReference(pinnedTrackReference) &&\n        pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid,\n    );\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReferencePlaceholder(pinnedTrackReference) &&\n        pinnedTrackReference.source === trackReference.source,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if the current `currentTrackRef` is the placeholder for next `nextTrackRef`.\n * Based on the participant identity and the source.\n * @internal\n */\nexport function isPlaceholderReplacement(\n  currentTrackRef: TrackReferenceOrPlaceholder,\n  nextTrackRef: TrackReferenceOrPlaceholder,\n) {\n  // if (typeof nextTrackRef === 'number' || typeof currentTrackRef === 'number') {\n  //   return false;\n  // }\n  return (\n    isTrackReferencePlaceholder(currentTrackRef) &&\n    isTrackReference(nextTrackRef) &&\n    nextTrackRef.participant.identity === currentTrackRef.participant.identity &&\n    nextTrackRef.source === currentTrackRef.source\n  );\n}\n","/**\n * @internal\n */\nexport function isWeb(): boolean {\n  return typeof document !== 'undefined';\n}\n\n/**\n * Mobile browser detection based on `navigator.userAgent` string.\n * Defaults to returning `false` if not in a browser.\n *\n * @remarks\n * This should only be used if feature detection or other methods do not work!\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_device_detection\n */\nexport function isMobileBrowser(): boolean {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n","// The MIT License (MIT)\n\n// Copyright (c) Kevin Mårtensson <kevinmartensson@gmail.com> and Diego Perini\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ninterface RegExOptions {\n  /**\n\t\tOnly match an exact string. Useful with `RegExp#test` to check if a string is a URL.\n\t\t@defaultValue false\n\t\t*/\n  readonly exact?: boolean;\n}\n\nexport function createUrlRegExp(options: RegExOptions) {\n  options = {\n    ...options,\n  };\n\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ip = new RegExp(\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}',\n    'g',\n  ).source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain = '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n\n  return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');\n}\n","// source code adapted from https://github.com/sindresorhus/email-regex due to ESM import incompatibilities when trying to serve a CJS version of components\n\nconst regex = '[^\\\\.\\\\s@:](?:[^\\\\s@:]*[^\\\\s@:\\\\.])?@[^\\\\.\\\\s@]+(?:\\\\.[^\\\\.\\\\s@]+)*';\n\nfunction createEmailRegExp({ exact }: { exact?: boolean } = {}) {\n  return exact ? new RegExp(`^${regex}$`) : new RegExp(regex, 'g');\n}\nexport { createEmailRegExp };\n","import { computePosition, flip, offset, shift } from '@floating-ui/dom';\n\nexport async function computeMenuPosition(\n  button: HTMLElement,\n  menu: HTMLElement,\n): Promise<{ x: number; y: number }> {\n  const { x, y } = await computePosition(button, menu, {\n    placement: 'top',\n    middleware: [offset(6), flip(), shift({ padding: 5 })],\n  });\n  return { x, y };\n}\n\nexport function wasClickOutside(insideElement: HTMLElement, event: MouseEvent): boolean {\n  const isOutside = !insideElement.contains(event.target as Node);\n  return isOutside;\n}\n","import { createEmailRegExp } from './emailRegex';\nimport { createUrlRegExp } from './url-regex';\n\nexport type TokenizeGrammar = { [type: string]: RegExp };\n\nexport const createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({}),\n  } satisfies TokenizeGrammar;\n};\n\nexport function tokenize<T extends TokenizeGrammar>(input: string, grammar: T) {\n  const matches = Object.entries(grammar)\n    .map(([type, rx], weight) =>\n      Array.from(input.matchAll(rx)).map(({ index, 0: content }) => ({\n        type: type as keyof T,\n        weight,\n        content,\n        index: index ?? 0,\n      })),\n    )\n    .flat()\n    .sort((a, b) => {\n      const d = a.index - b.index;\n      return d !== 0 ? d : a.weight - b.weight;\n    })\n    .filter(({ index }, i, arr) => {\n      if (i === 0) return true;\n      const prev = arr[i - 1];\n      return prev.index + prev.content.length <= index;\n    });\n\n  const tokens = [];\n  let pos = 0;\n  for (const { type, content, index } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({ type, content });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n","import { ParticipantEvent, RoomEvent } from 'livekit-client';\n\nexport const allRemoteParticipantRoomEvents = [\n  RoomEvent.ConnectionStateChanged,\n  RoomEvent.RoomMetadataChanged,\n\n  RoomEvent.ActiveSpeakersChanged,\n  RoomEvent.ConnectionQualityChanged,\n\n  RoomEvent.ParticipantConnected,\n  RoomEvent.ParticipantDisconnected,\n  RoomEvent.ParticipantPermissionsChanged,\n  RoomEvent.ParticipantMetadataChanged,\n\n  RoomEvent.TrackMuted,\n  RoomEvent.TrackUnmuted,\n  RoomEvent.TrackPublished,\n  RoomEvent.TrackUnpublished,\n  RoomEvent.TrackStreamStateChanged,\n  RoomEvent.TrackSubscriptionFailed,\n  RoomEvent.TrackSubscriptionPermissionChanged,\n  RoomEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantRoomEvents = [\n  ...allRemoteParticipantRoomEvents,\n  RoomEvent.LocalTrackPublished,\n  RoomEvent.LocalTrackUnpublished,\n];\n\nexport const participantTrackEvents = [\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscribed,\n  ParticipantEvent.TrackUnsubscribed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n\nexport const allRemoteParticipantEvents = [\n  ParticipantEvent.ConnectionQualityChanged,\n  ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent.ParticipantMetadataChanged,\n  ParticipantEvent.ParticipantPermissionsChanged,\n\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantEvents = [\n  ...allRemoteParticipantEvents,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n","import {\n  setLogLevel as setClientSdkLogLevel,\n  setLogExtension as setClientSdkLogExtension,\n  LogLevel as LogLevelEnum,\n} from 'livekit-client';\nimport loglevel from 'loglevel';\n\nexport const log = loglevel.getLogger('lk-components-js');\nlog.setDefaultLevel('WARN');\n\ntype LogLevel = Parameters<typeof setClientSdkLogLevel>[0];\ntype SetLogLevelOptions = {\n  liveKitClientLogLevel?: LogLevel;\n};\n\n/**\n * Set the log level for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log independently, use the `liveKitClientLogLevel` prop on the `options` object.\n * @public\n */\nexport function setLogLevel(level: LogLevel, options: SetLogLevelOptions = {}): void {\n  log.setLevel(level);\n  setClientSdkLogLevel(options.liveKitClientLogLevel ?? level);\n}\n\ntype LogExtension = (level: LogLevel, msg: string, context?: object) => void;\ntype SetLogExtensionOptions = {\n  liveKitClientLogExtension?: LogExtension;\n};\n\n/**\n * Set the log extension for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log extension, use the `liveKitClientLogExtension` prop on the `options` object.\n * @public\n */\nexport function setLogExtension(extension: LogExtension, options: SetLogExtensionOptions = {}) {\n  const originalFactory = log.methodFactory;\n\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n\n    return (msg, context?: [msg: string, context: object]) => {\n      if (context) rawMethod(msg, context);\n      else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel()); // Be sure to call setLevel method in order to apply plugin\n  setClientSdkLogExtension(options.liveKitClientLogExtension ?? extension);\n}\n","import { log } from '../logger';\n\nexport type GridLayoutDefinition = {\n  /** Layout name (convention `<column_count>x<row_count>`). */\n  name: string;\n  /** Column count of the layout. */\n  columns: number;\n  /** Row count of the layout. */\n  rows: number;\n  // # Constraints that have to be meet to use this layout.\n  // ## 1. Participant range:\n  /** Minimum number of tiles needed to use this layout. */\n  minTiles: number;\n  /** Maximum tiles that fit into this layout. */\n  maxTiles: number;\n  // ## 2. Screen size limits:\n  /** Minimum width required to use this layout. */\n  minWidth: number;\n  /** Minimum height required to use this layout. */\n  minHeight: number;\n};\n\nexport const GRID_LAYOUTS: GridLayoutDefinition[] = [\n  {\n    columns: 1,\n    rows: 1,\n    name: '1x1',\n    minTiles: 1,\n    maxTiles: 1,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 1,\n    rows: 2,\n    name: '1x2',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 1,\n    name: '2x1',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 900,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 2,\n    name: '2x2',\n    minTiles: 3,\n    maxTiles: 4,\n    minWidth: 560,\n    minHeight: 0,\n  },\n  {\n    columns: 3,\n    rows: 3,\n    name: '3x3',\n    minTiles: 5,\n    maxTiles: 9,\n    minWidth: 700,\n    minHeight: 0,\n  },\n  {\n    columns: 4,\n    rows: 4,\n    name: '4x4',\n    minTiles: 10,\n    maxTiles: 16,\n    minWidth: 960,\n    minHeight: 0,\n  },\n  {\n    columns: 5,\n    rows: 5,\n    name: '5x5',\n    minTiles: 17,\n    maxTiles: 25,\n    minWidth: 1100,\n    minHeight: 0,\n  },\n];\n\nexport function selectGridLayout(\n  layouts: GridLayoutDefinition[],\n  participantCount: number,\n  width: number,\n  height: number,\n): GridLayoutDefinition {\n  // Find the best layout to fit all participants.\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable =\n      allLayouts.findIndex((l, i) => {\n        const layoutIsBiggerThanCurrent = i > index;\n        const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n        return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n      }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === undefined) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(\n        `No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`,\n      );\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n\n  // Check if the layout fits into the screen constraints. If not, recursively check the next smaller layout.\n  if (width < layout.minWidth || height < layout.minHeight) {\n    // const currentLayoutIndex = layouts.indexOf(layout);\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(\n        layouts.slice(0, currentLayoutIndex),\n        smallerLayout.maxTiles,\n        width,\n        height,\n      );\n    }\n  }\n  return layout;\n}\n","export function setDifference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n","/**\n * Returns `true` if the browser supports screen sharing.\n */\nexport function supportsScreenSharing(): boolean {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.mediaDevices &&\n    !!navigator.mediaDevices.getDisplayMedia\n  );\n}\n","import type { TranscriptionSegment } from 'livekit-client';\n\nexport type ReceivedTranscriptionSegment = TranscriptionSegment & {\n  receivedAtMediaTimestamp: number;\n  receivedAt: number;\n};\n\nexport function getActiveTranscriptionSegments(\n  segments: ReceivedTranscriptionSegment[],\n  syncTimes: { timestamp: number; rtpTimestamp?: number },\n  maxAge = 0,\n) {\n  return segments.filter((segment) => {\n    const hasTrackSync = !!syncTimes.rtpTimestamp;\n    const currentTrackTime = syncTimes.rtpTimestamp ?? performance.timeOrigin + performance.now();\n    // if a segment arrives late, consider startTime to be the media timestamp from when the segment was received client side\n    const displayStartTime = hasTrackSync\n      ? Math.max(segment.receivedAtMediaTimestamp, segment.startTime)\n      : segment.receivedAt;\n    // \"active\" duration is computed by the diff between start and end time, so we don't rely on displayStartTime to always be the same as the segment's startTime\n    const segmentDuration = maxAge + segment.endTime - segment.startTime;\n    return (\n      currentTrackTime >= displayStartTime && currentTrackTime <= displayStartTime + segmentDuration\n    );\n  });\n}\n\nexport function addMediaTimestampToTranscription(\n  segment: TranscriptionSegment,\n  timestamps: { timestamp: number; rtpTimestamp?: number },\n): ReceivedTranscriptionSegment {\n  return {\n    ...segment,\n    receivedAtMediaTimestamp: timestamps.rtpTimestamp ?? 0,\n    receivedAt: timestamps.timestamp,\n  };\n}\n\n/**\n * @returns An array of unique (by id) `TranscriptionSegment`s. Latest wins. If the resulting array would be longer than `windowSize`, the array will be reduced to `windowSize` length\n */\nexport function dedupeSegments<T extends TranscriptionSegment>(\n  prevSegments: T[],\n  newSegments: T[],\n  windowSize: number,\n) {\n  return [...prevSegments, ...newSegments]\n    .reduceRight((acc, segment) => {\n      if (!acc.find((val) => val.id === segment.id)) {\n        acc.unshift(segment);\n      }\n      return acc;\n    }, [] as Array<T>)\n    .slice(0 - windowSize);\n}\n\nexport function didActiveSegmentsChange<T extends TranscriptionSegment>(\n  prevActive: T[],\n  newActive: T[],\n) {\n  if (newActive.length !== prevActive.length) {\n    return true;\n  }\n  return !newActive.every((newSegment) => {\n    return prevActive.find(\n      (prevSegment) =>\n        prevSegment.id === newSegment.id &&\n        prevSegment.text === newSegment.text &&\n        prevSegment.final === newSegment.final &&\n        prevSegment.language === newSegment.language &&\n        prevSegment.startTime === newSegment.startTime &&\n        prevSegment.endTime === newSegment.endTime,\n    );\n  });\n}\n","import type { Participant, ParticipantKind, Track, TrackPublication } from 'livekit-client';\nimport type { TrackReference, TrackReferenceOrPlaceholder } from './track-reference';\n\n// ## PinState Type\n/** @public */\nexport type PinState = TrackReferenceOrPlaceholder[];\nexport const PIN_DEFAULT_STATE: PinState = [];\n\n// ## WidgetState Types\n/** @public */\nexport type WidgetState = {\n  showChat: boolean;\n  unreadMessages: number;\n  showSettings?: boolean;\n};\nexport const WIDGET_DEFAULT_STATE: WidgetState = {\n  showChat: false,\n  unreadMessages: 0,\n  showSettings: false,\n};\n\n// ## Track Source Types\nexport type TrackSourceWithOptions = { source: Track.Source; withPlaceholder: boolean };\n\nexport type SourcesArray = Track.Source[] | TrackSourceWithOptions[];\n\n// ### Track Source Type Predicates\nexport function isSourceWitOptions(source: SourcesArray[number]): source is TrackSourceWithOptions {\n  return typeof source === 'object';\n}\n\nexport function isSourcesWithOptions(sources: SourcesArray): sources is TrackSourceWithOptions[] {\n  return (\n    Array.isArray(sources) &&\n    (sources as TrackSourceWithOptions[]).filter(isSourceWitOptions).length > 0\n  );\n}\n\n// ## Loop Filter Types\nexport type TrackReferenceFilter = Parameters<TrackReferenceOrPlaceholder[]['filter']>['0'];\nexport type ParticipantFilter = Parameters<Participant[]['filter']>['0'];\n\n// ## Other Types\n/** @internal */\nexport interface ParticipantClickEvent {\n  participant: Participant;\n  track?: TrackPublication;\n}\n\nexport type TrackSource<T extends Track.Source> = RequireAtLeastOne<\n  { source: T; name: string; participant: Participant },\n  'name' | 'source'\n>;\n\nexport type ParticipantTrackIdentifier = RequireAtLeastOne<\n  { sources: Track.Source[]; name: string; kind: Track.Kind },\n  'sources' | 'name' | 'kind'\n>;\n\n/**\n * @beta\n */\nexport type ParticipantIdentifier = RequireAtLeastOne<\n  { kind: ParticipantKind; identity: string },\n  'identity' | 'kind'\n>;\n\n/**\n * The TrackIdentifier type is used to select Tracks either based on\n * - Track.Source and/or name of the track, e.g. `{source: Track.Source.Camera}` or `{name: \"my-track\"}`\n * - TrackReference (participant and publication)\n * @internal\n */\nexport type TrackIdentifier<T extends Track.Source = Track.Source> =\n  | TrackSource<T>\n  | TrackReference;\n\n// ## Util Types\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type AudioSource = Track.Source.Microphone | Track.Source.ScreenShareAudio;\nexport type VideoSource = Track.Source.Camera | Track.Source.ScreenShare;\n","import { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { isTrackReference } from '../track-reference';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n  sortTrackReferencesByType,\n  sortTrackRefsByIsCameraEnabled,\n} from './base-sort-functions';\n\n/**\n * Default sort for `TrackReferenceOrPlaceholder`, it'll order participants by:\n * 1. local camera track (publication.isLocal)\n * 2. remote screen_share track\n * 3. local screen_share track\n * 4. remote dominant speaker camera track (sorted by speaker with the loudest audio level)\n * 5. other remote speakers that are recently active\n * 6. remote unmuted camera tracks\n * 7. remote tracks sorted by joinedAt\n */\nexport function sortTrackReferences(\n  tracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localTracks: TrackReferenceOrPlaceholder[] = [];\n  const screenShareTracks: TrackReferenceOrPlaceholder[] = [];\n  const cameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const undefinedTracks: TrackReferenceOrPlaceholder[] = [];\n\n  tracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal && trackRef.source === Track.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\n\n/**\n * Sort an array of `TrackReference` screen shares.\n * Main sorting order:\n * 1. remote screen shares\n * 2. local screen shares\n * Secondary sorting by participant's joining time.\n */\nfunction sortScreenShareTracks(\n  screenShareTracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localScreenShares: TrackReferenceOrPlaceholder[] = [];\n  const remoteScreenShares: TrackReferenceOrPlaceholder[] = [];\n\n  screenShareTracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\n\nfunction sortCameraTracks(\n  cameraTrackReferences: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localCameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const remoteCameraTracks: TrackReferenceOrPlaceholder[] = [];\n\n  cameraTrackReferences.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n\n  remoteCameraTracks.sort((a, b) => {\n    // Participant with higher audio level goes first.\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n\n    // A speaking participant goes before one that is not speaking.\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n\n    // A participant that spoke recently goes before a participant that spoke a while back.\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n\n    // TrackReference before TrackReferencePlaceholder\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n\n    // Tiles with video on before tiles with muted video track.\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n\n    // A participant that joined a long time ago goes before one that joined recently.\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n","import type { Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { getTrackReferenceSource, isTrackReference } from '../track-reference';\n\nexport function sortParticipantsByAudioLevel(\n  a: Pick<Participant, 'audioLevel'>,\n  b: Pick<Participant, 'audioLevel'>,\n): number {\n  return b.audioLevel - a.audioLevel;\n}\n\nexport function sortParticipantsByIsSpeaking(\n  a: Pick<Participant, 'isSpeaking'>,\n  b: Pick<Participant, 'isSpeaking'>,\n): number {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\n\nexport function sortParticipantsByLastSpokenAT(\n  a: Pick<Participant, 'lastSpokeAt'>,\n  b: Pick<Participant, 'lastSpokeAt'>,\n): number {\n  if (a.lastSpokeAt !== undefined || b.lastSpokeAt !== undefined) {\n    return (b.lastSpokeAt?.getTime() ?? 0) - (a.lastSpokeAt?.getTime() ?? 0);\n  } else {\n    return 0;\n  }\n}\n\nexport function sortParticipantsByJoinedAt(\n  a: Pick<Participant, 'joinedAt'>,\n  b: Pick<Participant, 'joinedAt'>,\n) {\n  return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n}\n\nexport function sortTrackReferencesByType(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/** TrackReference with screen share source goes first. */\nexport function sortTrackReferencesByScreenShare(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n): number {\n  const sourceA = getTrackReferenceSource(a);\n  const sourceB = getTrackReferenceSource(b);\n\n  if (sourceA === sourceB) {\n    if (sourceA === Track.Source.ScreenShare) {\n      if (a.participant.isLocal === b.participant.isLocal) {\n        return 0;\n      } else {\n        return a.participant.isLocal ? 1 : -1;\n      }\n    }\n    return 0;\n  } else if (sourceA === Track.Source.ScreenShare) {\n    return -1;\n  } else if (sourceB === Track.Source.ScreenShare) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function sortTrackRefsByIsCameraEnabled(\n  a: { participant: { isCameraEnabled: boolean } },\n  b: { participant: { isCameraEnabled: boolean } },\n) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n","import type { Participant } from 'livekit-client';\nimport { LocalParticipant } from 'livekit-client';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n} from './base-sort-functions';\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. local participant\n * 2. dominant speaker (speaker with the loudest audio level)\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(participants: Participant[]): Participant[] {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n\n    // video on\n    const aVideo = a.videoTrackPublications.size > 0;\n    const bVideo = b.videoTrackPublications.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find((p) => p instanceof LocalParticipant);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n","export function chunk<T>(input: Array<T>, size: number) {\n  return input.reduce(\n    (arr, item, idx) => {\n      return idx % size === 0\n        ? [...arr, [item]]\n        : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n    },\n    [] as Array<Array<T>>,\n  );\n}\n\nexport function zip<T, U>(a1: Array<T>, a2: Array<U>) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\n\nexport function differenceBy<T>(a1: Array<T>, a2: Array<T>, by: (arg: T) => string) {\n  return a1.filter((c) => !a2.map((v) => by(v)).includes(by(c)));\n}\n","/**\n * Internal test function.\n *\n * @internal\n */\n\nimport { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { UpdatableItem } from '../sorting/tile-array-update';\nimport type { TrackReference, TrackReferencePlaceholder } from './track-reference.types';\nimport { getTrackReferenceId } from './track-reference.utils';\n\n// Test function:\nexport const mockTrackReferencePlaceholder = (\n  id: string,\n  source: Track.Source,\n): TrackReferencePlaceholder => {\n  return { participant: new Participant(`${id}`, `${id}`), source };\n};\n\nexport const mockTrackReferencePublished = (id: string, source: Track.Source): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n  return {\n    participant: new Participant(`${id}`, `${id}`),\n    publication: new TrackPublication(kind, `${id}`, `${id}`),\n    source: source,\n  };\n};\n\ntype mockTrackReferenceSubscribedOptions = {\n  mockPublication?: boolean;\n  mockParticipant?: boolean;\n  mockIsLocal?: boolean;\n};\n\nexport const mockTrackReferenceSubscribed = (\n  id: string,\n  source: Track.Source,\n  options: mockTrackReferenceSubscribedOptions = {},\n): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n\n  const publication = new TrackPublication(kind, `${id}`, `${id}`);\n  // @ts-expect-error\n  publication.track = {};\n  return {\n    participant: options.mockParticipant\n      ? (mockParticipant(id, options.mockIsLocal ?? false) as Participant)\n      : new Participant(`${id}`, `${id}`),\n    publication: options.mockPublication\n      ? (mockTrackPublication(`publicationId(${id})`, kind, source) as TrackPublication)\n      : publication,\n    source,\n  };\n};\n\nconst mockTrackPublication = (\n  id: string,\n  kind: Track.Kind,\n  source: Track.Source,\n): Pick<TrackPublication, 'kind' | 'trackSid' | 'trackName' | 'source'> => {\n  return {\n    kind,\n    trackSid: id,\n    trackName: `name_${id}`,\n    source: source,\n  };\n};\n\nfunction mockParticipant(\n  id: string,\n  isLocal: boolean,\n): Pick<Participant, 'sid' | 'identity' | 'isLocal'> {\n  return {\n    sid: `${id}_sid`,\n    identity: `${id}`,\n    isLocal: isLocal,\n  };\n}\n\nexport function flatTrackReferenceArray<T extends UpdatableItem>(list: T[]): string[] {\n  return list.map((item) => {\n    if (typeof item === 'string' || typeof item === 'number') {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n","import { differenceBy, chunk, zip } from '../helper/array-helper';\nimport { log } from '../logger';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport {\n  getTrackReferenceId,\n  isPlaceholderReplacement,\n  isTrackReference,\n  isTrackReferencePlaceholder,\n} from '../track-reference';\nimport { flatTrackReferenceArray } from '../track-reference/test-utils';\n\ntype VisualChanges<T> = {\n  dropped: T[];\n  added: T[];\n};\n\nexport type UpdatableItem = TrackReferenceOrPlaceholder | number;\n\n/** Check to see if anything visually changes on the page. */\nexport function visualPageChange<T extends UpdatableItem>(state: T[], next: T[]): VisualChanges<T> {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId),\n  };\n}\n\nfunction listNeedsUpdating<T>(changes: VisualChanges<T>): boolean {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\n\nexport function findIndex<T extends UpdatableItem>(\n  trackReference: T,\n  trackReferences: T[],\n): number {\n  const indexToReplace = trackReferences.findIndex(\n    (trackReference_) =>\n      getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference),\n  );\n  if (indexToReplace === -1) {\n    throw new Error(\n      `Element not part of the array: ${getTrackReferenceId(\n        trackReference,\n      )} not in ${flatTrackReferenceArray(trackReferences)}`,\n    );\n  }\n  return indexToReplace;\n}\n\n/** Swap items in the complete list of all elements */\nexport function swapItems<T extends UpdatableItem>(\n  moveForward: T,\n  moveBack: T,\n  trackReferences: T[],\n): T[] {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n\n  return trackReferences;\n}\n\nexport function dropItem<T extends UpdatableItem>(itemToDrop: T, list: T[]): T[] {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  // const indexOfElementToDrop = list.findIndex((item) => item === itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\n\nfunction addItem<T extends UpdatableItem>(itemToAdd: T, list: T[]): T[] {\n  return [...list, itemToAdd];\n}\n\nexport function divideIntoPages<T>(list: T[], maxElementsOnPage: number): Array<T[]> {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\n\n/** Divide the list of elements into pages and and check if pages need updating. */\nexport function updatePages<T extends UpdatableItem>(\n  currentList: T[],\n  nextList: T[],\n  maxItemsOnPage: number,\n): T[] {\n  let updatedList: T[] = refreshList(currentList, nextList);\n\n  if (updatedList.length < nextList.length) {\n    // Items got added: Find newly added items and add them to the end of the list.\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      // 1) Identify  missing tile.\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n\n      if (listNeedsUpdating(changes)) {\n        log.debug(\n          `Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(\n            currentPage,\n          )}, next: ${flatTrackReferenceArray(nextPage)}`,\n          { changes },\n        );\n        // ## Swap Items\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems<T>(added, dropped, updatedList);\n            } else {\n              throw new Error(\n                `For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`,\n              );\n            }\n          });\n        }\n        // ## Handle Drop Items\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach((item) => {\n            updatedList = dropItem<T>(item, updatedList);\n          });\n        }\n        // ## Handle Item added\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach((item) => {\n            updatedList = addItem<T>(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n\n  if (updatedList.length > nextList.length) {\n    // Items got removed: Find items that got completely removed from the list.\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(\n      (item) => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)),\n    );\n  }\n\n  return updatedList;\n}\n\n/**\n * Update the current list with the items from the next list whenever the item ids are the same\n * or the current item is a placeholder and we find a track reference in the next list\n * to replace the placeholder with.\n * @remarks\n * This is needed because `TrackReference`s can change their internal state while keeping the same id.\n */\nfunction refreshList<T extends UpdatableItem>(currentList: T[], nextList: T[]): T[] {\n  return currentList.map((currentItem) => {\n    const updateForCurrentItem = nextList.find(\n      (newItem_) =>\n        // If the IDs match or ..\n        getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n        // ... if the current item is a placeholder and the new item is the track reference can replace it.\n        (typeof currentItem !== 'number' &&\n          isTrackReferencePlaceholder(currentItem) &&\n          isTrackReference(newItem_) &&\n          isPlaceholderReplacement(currentItem, newItem_)),\n    );\n    return updateForCurrentItem ?? currentItem;\n  });\n}\n","import type {\n  AudioCaptureOptions,\n  LocalParticipant,\n  Room,\n  ScreenShareCaptureOptions,\n  TrackPublishOptions,\n  VideoCaptureOptions,\n} from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { Observable } from 'rxjs';\nimport { Subject, map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport type CaptureOptionsBySource<T extends ToggleSource> = T extends Track.Source.Camera\n  ? VideoCaptureOptions\n  : T extends Track.Source.Microphone\n    ? AudioCaptureOptions\n    : T extends Track.Source.ScreenShare\n      ? ScreenShareCaptureOptions\n      : never;\n\nexport type MediaToggleType<T extends ToggleSource> = {\n  pendingObserver: Observable<boolean>;\n  toggle: (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => Promise<void>;\n  className: string;\n  enabledObserver: Observable<boolean>;\n};\n\nexport type ToggleSource = Exclude<\n  Track.Source,\n  Track.Source.ScreenShareAudio | Track.Source.Unknown\n>;\n\nexport function setupMediaToggle<T extends ToggleSource>(\n  source: T,\n  room: Room,\n  options?: CaptureOptionsBySource<T>,\n  publishOptions?: TrackPublishOptions,\n  onError?: (error: Error) => void,\n): MediaToggleType<T> {\n  const { localParticipant } = room;\n\n  const getSourceEnabled = (source: ToggleSource, localParticipant: LocalParticipant) => {\n    let isEnabled = false;\n    switch (source) {\n      case Track.Source.Camera:\n        isEnabled = localParticipant.isCameraEnabled;\n        break;\n      case Track.Source.Microphone:\n        isEnabled = localParticipant.isMicrophoneEnabled;\n        break;\n      case Track.Source.ScreenShare:\n        isEnabled = localParticipant.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(\n    map((media) => {\n      return getSourceEnabled(source, media.participant as LocalParticipant);\n    }),\n    startWith(getSourceEnabled(source, localParticipant)),\n  );\n\n  const pendingSubject = new Subject<boolean>();\n  const toggle = async (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => {\n    try {\n      captureOptions ??= options;\n      // trigger observable update\n      pendingSubject.next(true);\n      switch (source) {\n        case Track.Source.Camera:\n          await localParticipant.setCameraEnabled(\n            forceState ?? !localParticipant.isCameraEnabled,\n            captureOptions as VideoCaptureOptions,\n            publishOptions,\n          );\n          break;\n        case Track.Source.Microphone:\n          await localParticipant.setMicrophoneEnabled(\n            forceState ?? !localParticipant.isMicrophoneEnabled,\n            captureOptions as AudioCaptureOptions,\n            publishOptions,\n          );\n          break;\n        case Track.Source.ScreenShare:\n          await localParticipant.setScreenShareEnabled(\n            forceState ?? !localParticipant.isScreenShareEnabled,\n            captureOptions as ScreenShareCaptureOptions,\n            publishOptions,\n          );\n          break;\n        default:\n          break;\n      }\n    } catch (e) {\n      if (onError && e instanceof Error) {\n        onError?.(e);\n      } else {\n        throw e;\n      }\n    } finally {\n      pendingSubject.next(false);\n      // trigger observable update\n    }\n  };\n\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n\nexport function setupManualToggle() {\n  let state = false;\n\n  const enabledSubject = new Subject<boolean>();\n\n  const pendingSubject = new Subject<boolean>();\n\n  const toggle = async (forceState?: boolean) => {\n    pendingSubject.next(true);\n    state = forceState ?? !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  };\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n","import type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant, RemoteParticipant, Room, TrackPublication } from 'livekit-client';\nimport { ParticipantEvent, RoomEvent, Track } from 'livekit-client';\nimport type { ParticipantEventCallbacks } from 'livekit-client/dist/src/room/participant/Participant';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, map, startWith, switchMap } from 'rxjs';\nimport { getTrackByIdentifier } from '../components/mediaTrack';\nimport { allParticipantEvents, allParticipantRoomEvents } from '../helper/eventGroups';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport type { ParticipantIdentifier, TrackIdentifier } from '../types';\nimport { observeRoomEvents } from './room';\n\nexport function observeParticipantEvents<T extends Participant>(\n  participant: T,\n  ...events: ParticipantEvent[]\n) {\n  const observable = new Observable<T>((subscribe) => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n\n    events.forEach((evt) => {\n      participant.on(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        participant.off(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(participant));\n\n  return observable;\n}\n\nexport interface ParticipantMedia<T extends Participant = Participant> {\n  isCameraEnabled: boolean;\n  isMicrophoneEnabled: boolean;\n  isScreenShareEnabled: boolean;\n  microphoneTrack?: TrackPublication;\n  cameraTrack?: TrackPublication;\n  participant: T;\n}\n\nexport function observeParticipantMedia<T extends Participant>(participant: T) {\n  const participantObserver = observeParticipantEvents(\n    participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.ParticipantPermissionsChanged,\n    // ParticipantEvent.IsSpeakingChanged,\n    ParticipantEvent.TrackPublished,\n    ParticipantEvent.TrackUnpublished,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n    ParticipantEvent.MediaDevicesError,\n    ParticipantEvent.TrackSubscriptionStatusChanged,\n    // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map((p) => {\n      const { isMicrophoneEnabled, isCameraEnabled, isScreenShareEnabled } = p;\n      const microphoneTrack = p.getTrackPublication(Track.Source.Microphone);\n      const cameraTrack = p.getTrackPublication(Track.Source.Camera);\n      const participantMedia: ParticipantMedia<T> = {\n        isCameraEnabled,\n        isMicrophoneEnabled,\n        isScreenShareEnabled,\n        cameraTrack,\n        microphoneTrack,\n        participant: p,\n      };\n      return participantMedia;\n    }),\n  );\n\n  return participantObserver;\n}\n\nexport function createTrackObserver(participant: Participant, options: TrackIdentifier) {\n  return observeParticipantMedia(participant).pipe(\n    map(() => {\n      return { publication: getTrackByIdentifier(options) };\n    }),\n  );\n}\n\nexport function participantInfoObserver(participant: Participant) {\n  const observer = observeParticipantEvents(\n    participant,\n    ParticipantEvent.ParticipantMetadataChanged,\n    ParticipantEvent.ParticipantNameChanged,\n  ).pipe(\n    map(({ name, identity, metadata }) => {\n      return {\n        name,\n        identity,\n        metadata,\n      };\n    }),\n    startWith({\n      name: participant.name,\n      identity: participant.identity,\n      metadata: participant.metadata,\n    }),\n  );\n  return observer;\n}\n\nexport function createConnectionQualityObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map(([quality]) => quality),\n    startWith(participant.connectionQuality),\n  );\n  return observer;\n}\n\nexport function participantEventSelector<T extends ParticipantEvent>(\n  participant: Participant,\n  event: T,\n) {\n  const observable = new Observable<\n    Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n  >((subscribe) => {\n    const update = (\n      ...params: Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n    ) => {\n      subscribe.next(params);\n    };\n    // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n    participant.on(event, update);\n\n    const unsubscribe = () => {\n      // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function mutedObserver(trackRef: TrackReferenceOrPlaceholder) {\n  return observeParticipantEvents(\n    trackRef.participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.TrackSubscribed,\n    ParticipantEvent.TrackUnsubscribed,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n  ).pipe(\n    map((participant) => {\n      const pub = trackRef.publication ?? participant.getTrackPublication(trackRef.source);\n      return pub?.isMuted ?? true;\n    }),\n    startWith(\n      trackRef.publication?.isMuted ??\n        trackRef.participant.getTrackPublication(trackRef.source)?.isMuted ??\n        true,\n    ),\n  );\n}\n\nexport function createIsSpeakingObserver(participant: Participant) {\n  return participantEventSelector(participant, ParticipantEvent.IsSpeakingChanged).pipe(\n    map(([isSpeaking]) => isSpeaking),\n  );\n}\n\ntype ConnectedParticipantsObserverOptions = {\n  additionalRoomEvents?: RoomEvent[];\n};\n\nexport function connectedParticipantsObserver(\n  room: Room,\n  options: ConnectedParticipantsObserverOptions = {},\n) {\n  let subscriber: Subscriber<RemoteParticipant[]> | undefined;\n\n  const observable = new Observable<RemoteParticipant[]>((sub) => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith(Array.from(room.remoteParticipants.values())));\n\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      ...additionalRoomEvents,\n    ]),\n  );\n\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe((r) =>\n    subscriber?.next(Array.from(r.remoteParticipants.values())),\n  );\n  if (room.remoteParticipants.size > 0) {\n    subscriber?.next(Array.from(room.remoteParticipants.values()));\n  }\n  return observable;\n}\n\nexport type ConnectedParticipantObserverOptions = {\n  additionalEvents?: ParticipantEvent[];\n};\n\nexport function connectedParticipantObserver(\n  room: Room,\n  identity: string,\n  options: ConnectedParticipantObserverOptions = {},\n) {\n  const additionalEvents = options.additionalEvents ?? allParticipantEvents;\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    switchMap((r) => {\n      const participant = r.getParticipantByIdentity(identity) as RemoteParticipant | undefined;\n      if (participant) {\n        return observeParticipantEvents(participant, ...additionalEvents);\n      } else {\n        return new Observable<undefined>((subscribe) => subscribe.next(undefined));\n      }\n    }),\n    startWith(room.getParticipantByIdentity(identity) as RemoteParticipant | undefined),\n  );\n\n  return observable;\n}\n\nexport function participantPermissionObserver(\n  participant: Participant,\n): Observable<ParticipantPermission | undefined> {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ParticipantPermissionsChanged,\n  ).pipe(\n    map(() => participant.permissions),\n    startWith(participant.permissions),\n  );\n  return observer;\n}\n\nexport function participantByIdentifierObserver(\n  room: Room,\n  { kind, identity }: ParticipantIdentifier,\n  options: ConnectedParticipantObserverOptions = {},\n): Observable<RemoteParticipant | undefined> {\n  const additionalEvents = options.additionalEvents ?? allParticipantEvents;\n  const matchesIdentifier = (participant: RemoteParticipant) => {\n    let isMatch = true;\n    if (kind) {\n      isMatch = isMatch && participant.kind === kind;\n    }\n    if (identity) {\n      isMatch = isMatch && participant.identity === identity;\n    }\n    return isMatch;\n  };\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    switchMap((r) => {\n      const participant = Array.from(r.remoteParticipants.values()).find((p) =>\n        matchesIdentifier(p),\n      );\n      if (participant) {\n        return observeParticipantEvents(participant, ...additionalEvents);\n      } else {\n        return new Observable<undefined>((subscribe) => subscribe.next(undefined));\n      }\n    }),\n    startWith(Array.from(room.remoteParticipants.values()).find((p) => matchesIdentifier(p))),\n  );\n\n  return observable;\n}\n","import { Track } from 'livekit-client';\nimport { map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport { isTrackReference } from '../track-reference/track-reference.types';\nimport type { TrackIdentifier } from '../types';\n\nexport function setupMediaTrack(trackIdentifier: TrackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(\n    map(() => {\n      return getTrackByIdentifier(trackIdentifier);\n    }),\n    startWith(initialPub),\n  );\n  const className: string = prefixClass(\n    trackIdentifier.source === Track.Source.Camera ||\n      trackIdentifier.source === Track.Source.ScreenShare\n      ? 'participant-media-video'\n      : 'participant-media-audio',\n  );\n  return { className, trackObserver };\n}\n\nexport function getTrackByIdentifier(options: TrackIdentifier) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const { source, name, participant } = options;\n    if (source && name) {\n      return participant\n        .getTrackPublications()\n        .find((pub) => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackPublicationByName(name);\n    } else if (source) {\n      return participant.getTrackPublication(source);\n    } else {\n      throw new Error('At least one of source and name needs to be defined');\n    }\n  }\n}\n","import type { UnprefixedClassNames as ComponentNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport type { UnprefixedClassNames as PrefabNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/prefabs/index.scss';\nimport { cssPrefix } from './../constants';\n\ntype UnprefixedClassNames = ComponentNoPrefixClasses | PrefabNoPrefixClasses;\n\n/**\n * This function is a type safe way to add a prefix to a HTML class attribute.\n * Only classes defined in the styles module are valid, any other class produces a ts error.\n * @internal\n */\nexport function prefixClass<T extends UnprefixedClassNames>(unprefixedClassName: T) {\n  return `${cssPrefix}-${unprefixedClassName}` as const;\n}\n","import type { Subscriber, Subscription } from 'rxjs';\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from 'rxjs';\nimport type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, Room, RoomEvent, Track } from 'livekit-client';\nimport type { RoomEventCallbacks } from 'livekit-client/dist/src/room/Room';\nimport { log } from '../logger';\nexport function observeRoomEvents(room: Room, ...events: RoomEvent[]): Observable<Room> {\n  const observable = new Observable<Room>((subscribe) => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n\n    events.forEach((evt) => {\n      room.on(evt, onRoomUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function roomEventSelector<T extends RoomEvent>(room: Room, event: T) {\n  const observable = new Observable<Parameters<RoomEventCallbacks[T]>>((subscribe) => {\n    const update = (...params: Parameters<RoomEventCallbacks[T]>) => {\n      subscribe.next(params);\n    };\n    room.on(event as keyof RoomEventCallbacks, update);\n\n    const unsubscribe = () => {\n      room.off(event as keyof RoomEventCallbacks, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function roomObserver(room: Room) {\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ActiveSpeakersChanged,\n    RoomEvent.TrackSubscribed,\n    RoomEvent.TrackUnsubscribed,\n    RoomEvent.LocalTrackPublished,\n    RoomEvent.LocalTrackUnpublished,\n    RoomEvent.AudioPlaybackStatusChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function connectionStateObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ConnectionStateChanged).pipe(\n    map(([connectionState]) => connectionState),\n    startWith(room.state),\n  );\n}\nexport type ScreenShareTrackMap = Array<{\n  participant: Participant;\n  tracks: Array<TrackPublication>;\n}>;\n\nexport function screenShareObserver(room: Room) {\n  let screenShareSubscriber: Subscriber<ScreenShareTrackMap>;\n  const observers: Array<Subscription> = [];\n\n  const observable = new Observable<ScreenShareTrackMap>((subscriber) => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach((observer) => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks: ScreenShareTrackMap = [];\n\n  const handleSub = (publication: TrackPublication, participant: Participant) => {\n    if (\n      publication.source !== Track.Source.ScreenShare &&\n      publication.source !== Track.Source.ScreenShareAudio\n    ) {\n      return;\n    }\n    let trackMap = screenShareTracks.find((tr) => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = (participant: Participant) => {\n      return participant\n        .getTrackPublications()\n        .filter(\n          (track) =>\n            (track.source === Track.Source.ScreenShare ||\n              track.source === Track.Source.ScreenShareAudio) &&\n            track.track,\n        );\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant),\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackSubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnsubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackPublished).subscribe((args) => handleSub(...args)),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackUnpublished).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackMuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnmuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  setTimeout(() => {\n    // TODO find way to avoid this timeout\n    for (const p of room.remoteParticipants.values()) {\n      p.getTrackPublications().forEach((track) => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n\n  return observable;\n}\n\nexport function roomInfoObserver(room: Room) {\n  const observer = observeRoomEvents(\n    room,\n    RoomEvent.RoomMetadataChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    map((r) => {\n      return { name: r.name, metadata: r.metadata };\n    }),\n  );\n  return observer;\n}\n\nexport function activeSpeakerObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ActiveSpeakersChanged).pipe(\n    map(([speakers]) => speakers),\n  );\n}\n\nexport function createMediaDeviceObserver(\n  kind?: MediaDeviceKind,\n  onError?: (e: Error) => void,\n  requestPermissions = true,\n) {\n  const onDeviceChange = async () => {\n    try {\n      const newDevices = await Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e: any) {\n      onError?.(e);\n    }\n  };\n  const deviceSubject = new Subject<MediaDeviceInfo[]>();\n\n  const observable = deviceSubject.pipe(\n    finalize(() => {\n      navigator?.mediaDevices?.removeEventListener('devicechange', onDeviceChange);\n    }),\n  );\n\n  if (typeof window !== 'undefined') {\n    if (!window.isSecureContext) {\n      throw new Error(\n        `Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`,\n      );\n    }\n    navigator?.mediaDevices?.addEventListener('devicechange', onDeviceChange);\n  }\n  // because we rely on an async function, concat the promise to retrieve the initial values with the observable\n  return concat(\n    Room.getLocalDevices(kind, requestPermissions).catch((e) => {\n      onError?.(e);\n      return [] as MediaDeviceInfo[];\n    }),\n    observable,\n  );\n}\n\nexport function createDataObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.DataReceived);\n}\n\nexport function roomAudioPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.AudioPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayAudio: room.canPlaybackAudio };\n    }),\n  );\n  return observable;\n}\n\nexport function roomVideoPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.VideoPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayVideo: room.canPlaybackVideo };\n    }),\n  );\n  return observable;\n}\n\nexport function createActiveDeviceObservable(room: Room, kind: MediaDeviceKind) {\n  return roomEventSelector(room, RoomEvent.ActiveDeviceChanged).pipe(\n    filter(([kindOfDevice]) => kindOfDevice === kind),\n    map(([kind, deviceId]) => {\n      log.debug('activeDeviceObservable | RoomEvent.ActiveDeviceChanged', { kind, deviceId });\n      return deviceId;\n    }),\n    startWith(room.getActiveDevice(kind)),\n  );\n}\n\nexport function encryptionStatusObservable(room: Room, participant: Participant) {\n  return roomEventSelector(room, RoomEvent.ParticipantEncryptionStatusChanged).pipe(\n    filter(\n      ([, p]) =>\n        participant.identity === p?.identity ||\n        (!p && participant.identity === room.localParticipant.identity),\n    ),\n    map(([encrypted]) => encrypted),\n    startWith(\n      participant instanceof LocalParticipant ? participant.isE2EEEnabled : participant.isEncrypted,\n    ),\n  );\n}\n","import {\n  Track,\n  type LocalAudioTrack,\n  type LocalVideoTrack,\n  type Room,\n  type LocalTrack,\n} from 'livekit-client';\nimport { BehaviorSubject } from 'rxjs';\nimport { log } from '../logger';\nimport { prefixClass } from '../styles-interface';\nimport { createActiveDeviceObservable } from '../observables/room';\n\nexport type SetMediaDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\nexport function setupDeviceSelector(\n  kind: MediaDeviceKind,\n  room?: Room,\n  localTrack?: LocalAudioTrack | LocalVideoTrack,\n) {\n  const activeDeviceSubject = new BehaviorSubject<string | undefined>(undefined);\n\n  const activeDeviceObservable = room\n    ? createActiveDeviceObservable(room, kind)\n    : activeDeviceSubject.asObservable();\n\n  const setActiveMediaDevice = async (id: string, options: SetMediaDeviceOptions = {}) => {\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      await room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId: string | undefined = room.getActiveDevice(kind) ?? id;\n      if (actualDeviceId !== id && id !== 'default') {\n        log.info(\n          `We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`,\n        );\n      }\n      let targetTrack: LocalTrack | undefined = undefined;\n      if (kind === 'audioinput')\n        targetTrack = room.localParticipant.getTrackPublication(Track.Source.Microphone)?.track;\n      else if (kind === 'videoinput') {\n        targetTrack = room.localParticipant.getTrackPublication(Track.Source.Camera)?.track;\n      }\n      const useDefault =\n        (id === 'default' && !targetTrack) ||\n        (id === 'default' && targetTrack?.mediaStreamTrack.label.startsWith('Default'));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      await localTrack.setDeviceId(options.exact ? { exact: id } : id);\n      const actualId = await localTrack.getDeviceId();\n      activeDeviceSubject.next(\n        id === 'default' && localTrack.mediaStreamTrack.label.startsWith('Default') ? id : actualId,\n      );\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\n        'device switch skipped, please provide either a room or a local track to switch on. ',\n      );\n      activeDeviceSubject.next(id);\n    }\n  };\n  const className: string = prefixClass('media-device-select');\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice,\n  };\n}\n","import type { Room } from 'livekit-client';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupDisconnectButton(room: Room) {\n  const disconnect = (stopTracks?: boolean) => {\n    room.disconnect(stopTracks);\n  };\n  const className: string = prefixClass('disconnect-button');\n  return { className, disconnect };\n}\n","import type { Participant } from 'livekit-client';\nimport { createConnectionQualityObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupConnectionQualityIndicator(participant: Participant) {\n  const className = prefixClass('connection-quality');\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return { className, connectionQualityObserver };\n}\n","import type { Styles } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport { Track } from 'livekit-client';\nimport { mutedObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function setupTrackMutedIndicator(trackRef: TrackReferenceOrPlaceholder) {\n  let classForSource: keyof Styles = 'track-muted-indicator-camera';\n  switch (trackRef.source) {\n    case Track.Source.Camera:\n      classForSource = 'track-muted-indicator-camera';\n      break;\n    case Track.Source.Microphone:\n      classForSource = 'track-muted-indicator-microphone';\n      break;\n\n    default:\n      break;\n  }\n  const className: string = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n\n  return { className, mediaMutedObserver };\n}\n","import type { Participant } from 'livekit-client';\nimport { participantInfoObserver } from '../observables/participant';\n\nexport function setupParticipantName(participant: Participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return { className: 'lk-participant-name', infoObserver };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupParticipantTile() {\n  const className: string = prefixClass('participant-tile');\n  return {\n    className,\n  };\n}\n","/* eslint-disable camelcase */\nimport type { Participant, Room } from 'livekit-client';\nimport { RoomEvent } from 'livekit-client';\nimport { BehaviorSubject, Subject, scan, map, takeUntil } from 'rxjs';\nimport { DataTopic, sendMessage, setupDataMessageHandler } from '../observables/dataChannel';\n\n/** @public */\nexport interface ChatMessage {\n  id: string;\n  timestamp: number;\n  message: string;\n}\n\n/** @public */\nexport interface ReceivedChatMessage extends ChatMessage {\n  from?: Participant;\n  editTimestamp?: number;\n}\n\n/** @public */\nexport type MessageEncoder = (message: ChatMessage) => Uint8Array;\n/** @public */\nexport type MessageDecoder = (message: Uint8Array) => ReceivedChatMessage;\n/** @public */\nexport type ChatOptions = {\n  messageEncoder?: (message: ChatMessage) => Uint8Array;\n  messageDecoder?: (message: Uint8Array) => ReceivedChatMessage;\n  channelTopic?: string;\n  updateChannelTopic?: string;\n};\n\ntype RawMessage = {\n  payload: Uint8Array;\n  topic: string | undefined;\n  from: Participant | undefined;\n};\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nconst topicSubjectMap: Map<Room, Map<string, Subject<RawMessage>>> = new Map();\n\nconst encode = (message: ChatMessage) => encoder.encode(JSON.stringify(message));\n\nconst decode = (message: Uint8Array) => JSON.parse(decoder.decode(message)) as ReceivedChatMessage;\n\nexport function setupChat(room: Room, options?: ChatOptions) {\n  const onDestroyObservable = new Subject<void>();\n\n  const { messageDecoder, messageEncoder, channelTopic, updateChannelTopic } = options ?? {};\n\n  const topic = channelTopic ?? DataTopic.CHAT;\n\n  const updateTopic = updateChannelTopic ?? DataTopic.CHAT_UPDATE;\n\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = topicSubjectMap.get(room) ?? new Map<string, Subject<RawMessage>>();\n  const messageSubject = topicMap.get(topic) ?? new Subject<RawMessage>();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n\n  if (needsSetup) {\n    /** Subscribe to all appropriate messages sent over the wire. */\n    const { messageObservable } = setupDataMessageHandler(room, [topic, updateTopic]);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n\n  const finalMessageDecoder = messageDecoder ?? decode;\n\n  /** Build up the message array over time. */\n  const messagesObservable = messageSubject.pipe(\n    map((msg) => {\n      const parsedMessage = finalMessageDecoder(msg.payload);\n      const newMessage: ReceivedChatMessage = { ...parsedMessage, from: msg.from };\n      return newMessage;\n    }),\n    scan<ReceivedChatMessage, ReceivedChatMessage[]>((acc, value) => {\n      // handle message updates\n      if (\n        'id' in value &&\n        acc.find((msg) => msg.from?.identity === value.from?.identity && msg.id === value.id)\n      ) {\n        const replaceIndex = acc.findIndex((msg) => msg.id === value.id);\n        if (replaceIndex > -1) {\n          const originalMsg = acc[replaceIndex];\n          acc[replaceIndex] = {\n            ...value,\n            timestamp: originalMsg.timestamp,\n            editTimestamp: value.timestamp,\n          };\n        }\n\n        return [...acc];\n      }\n      return [...acc, value];\n    }, []),\n    takeUntil(onDestroyObservable),\n  );\n\n  const isSending$ = new BehaviorSubject<boolean>(false);\n\n  const finalMessageEncoder = messageEncoder ?? encode;\n\n  const send = async (message: string) => {\n    const timestamp = Date.now();\n    const id = crypto.randomUUID();\n    const chatMessage: ChatMessage = { id, message, timestamp };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, {\n        reliable: true,\n        topic,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  const update = async (message: string, messageId: string) => {\n    const timestamp = Date.now();\n    const chatMessage: ChatMessage = { id: messageId, message, timestamp };\n    const encodedMsg = finalMessageEncoder(chatMessage);\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, {\n        topic: updateTopic,\n        reliable: true,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n      return chatMessage;\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.delete(room);\n  }\n  room.once(RoomEvent.Disconnected, destroy);\n\n  return { messageObservable: messagesObservable, isSendingObservable: isSending$, send, update };\n}\n","import type { DataPublishOptions, LocalParticipant, Participant, Room } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, filter, map } from 'rxjs';\nimport { createDataObserver } from './room';\n\nexport const DataTopic = {\n  CHAT: 'lk-chat-topic',\n  CHAT_UPDATE: 'lk-chat-update-topic',\n} as const;\n\n/** Publish data from the LocalParticipant. */\nexport async function sendMessage(\n  localParticipant: LocalParticipant,\n  payload: Uint8Array,\n  options: DataPublishOptions = {},\n) {\n  const { reliable, destinationIdentities, topic } = options;\n\n  await localParticipant.publishData(payload, {\n    destinationIdentities,\n    topic,\n    reliable,\n  });\n}\n\nexport interface BaseDataMessage<T extends string | undefined> {\n  topic?: T;\n  payload: Uint8Array;\n}\n\nexport interface ReceivedDataMessage<T extends string | undefined = string>\n  extends BaseDataMessage<T> {\n  from?: Participant;\n}\n\nexport function setupDataMessageHandler<T extends string>(\n  room: Room,\n  topic?: T | [T, ...T[]],\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const topics = Array.isArray(topic) ? topic : [topic];\n  /** Setup a Observable that returns all data messages belonging to a topic. */\n  const messageObservable = createDataObserver(room).pipe(\n    filter(\n      ([, , , messageTopic]) =>\n        topic === undefined || (messageTopic !== undefined && topics.includes(messageTopic as T)),\n    ),\n    map(([payload, participant, , messageTopic]) => {\n      const msg = {\n        payload,\n        topic: messageTopic as T,\n        from: participant,\n      } satisfies ReceivedDataMessage<T>;\n      onMessage?.(msg);\n      return msg;\n    }),\n  );\n\n  let isSendingSubscriber: Subscriber<boolean>;\n  const isSendingObservable = new Observable<boolean>((subscriber) => {\n    isSendingSubscriber = subscriber;\n  });\n\n  const send = async (payload: Uint8Array, options: DataPublishOptions = {}) => {\n    isSendingSubscriber.next(true);\n    try {\n      await sendMessage(room.localParticipant, payload, { topic: topics[0], ...options });\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  };\n\n  return { messageObservable, isSendingObservable, send };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomAudioPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartAudio() {\n  const handleStartAudioPlayback = async (room: Room) => {\n    log.info('Start Audio for room: ', room);\n    await room.startAudio();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomVideoPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartVideo() {\n  const handleStartVideoPlayback = async (room: Room) => {\n    log.info('Start Video for room: ', room);\n    await room.startVideo();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupChatToggle() {\n  const className: string = [prefixClass('button'), prefixClass('chat-toggle')].join(' ');\n  return { className };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupFocusToggle() {\n  const className: string = [prefixClass('button'), prefixClass('focus-toggle-button')].join(' ');\n  return { className };\n}\n","// import { prefixClass } from '../styles-interface';\n\nexport function setupClearPinButton() {\n  // const className = prefixClass('clear-pin-button');\n  const className = 'lk-clear-pin-button lk-button';\n  return { className };\n}\n","export function setupLiveKitRoom() {\n  const className = 'lk-room-container';\n  return { className };\n}\n","import type {\n  LocalTrackPublication,\n  Participant,\n  RemoteTrackPublication,\n  Room,\n  Track,\n  TrackPublication,\n} from 'livekit-client';\nimport { RoomEvent, TrackEvent } from 'livekit-client';\nimport { map, Observable, startWith } from 'rxjs';\nimport { allParticipantRoomEvents, participantTrackEvents } from '../helper';\nimport { log } from '../logger';\nimport type { TrackReference } from '../track-reference';\nimport { observeRoomEvents } from './room';\nimport type { ParticipantTrackIdentifier } from '../types';\nimport { observeParticipantEvents } from './participant';\nimport type { PublicationEventCallbacks } from 'livekit-client/dist/src/room/track/TrackPublication';\n\nexport function trackObservable(track: TrackPublication) {\n  const trackObserver = observeTrackEvents(\n    track,\n    TrackEvent.Muted,\n    TrackEvent.Unmuted,\n    TrackEvent.Subscribed,\n    TrackEvent.Unsubscribed,\n  );\n\n  return trackObserver;\n}\n\nexport function observeTrackEvents(track: TrackPublication, ...events: TrackEvent[]) {\n  const observable = new Observable<TrackPublication>((subscribe) => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n\n    events.forEach((evt) => {\n      // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n      track.on(evt, onTrackUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(track));\n\n  return observable;\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getTrackReferences(\n  room: Room,\n  sources: Track.Source[],\n  onlySubscribedTracks = true,\n): { trackReferences: TrackReference[]; participants: Participant[] } {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.remoteParticipants.values())];\n  const trackReferences: TrackReference[] = [];\n\n  allParticipants.forEach((participant) => {\n    sources.forEach((source) => {\n      const sourceReferences = Array.from<RemoteTrackPublication | LocalTrackPublication>(\n        participant.trackPublications.values(),\n      )\n        .filter(\n          (track) =>\n            track.source === source &&\n            // either return all or only the ones that are subscribed\n            (!onlySubscribedTracks || track.track),\n        )\n        .map((track): TrackReference => {\n          return {\n            participant: participant,\n            publication: track,\n            source: track.source,\n          };\n        });\n\n      trackReferences.push(...sourceReferences);\n    });\n  });\n\n  return { trackReferences, participants: allParticipants };\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getParticipantTrackRefs(\n  participant: Participant,\n  identifier: ParticipantTrackIdentifier,\n  onlySubscribedTracks = false,\n): TrackReference[] {\n  const { sources, kind, name } = identifier;\n  const sourceReferences = Array.from(participant.trackPublications.values())\n    .filter(\n      (pub) =>\n        (!sources || sources.includes(pub.source)) &&\n        (!kind || pub.kind === kind) &&\n        (!name || pub.trackName === name) &&\n        // either return all or only the ones that are subscribed\n        (!onlySubscribedTracks || pub.track),\n    )\n    .map((track): TrackReference => {\n      return {\n        participant: participant,\n        publication: track,\n        source: track.source,\n      };\n    });\n\n  return sourceReferences;\n}\n\ntype TrackReferencesObservableOptions = {\n  additionalRoomEvents?: RoomEvent[];\n  onlySubscribed?: boolean;\n};\n\nexport function trackReferencesObservable(\n  room: Room,\n  sources: Track.Source[],\n  options: TrackReferencesObservableOptions,\n): Observable<{ trackReferences: TrackReference[]; participants: Participant[] }> {\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n  const onlySubscribedTracks: boolean = options.onlySubscribed ?? true;\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      RoomEvent.LocalTrackPublished,\n      RoomEvent.LocalTrackUnpublished,\n      RoomEvent.TrackPublished,\n      RoomEvent.TrackUnpublished,\n      RoomEvent.TrackSubscriptionStatusChanged,\n      ...additionalRoomEvents,\n    ]).values(),\n  );\n\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(\n    map((room) => {\n      const data = getTrackReferences(room, sources, onlySubscribedTracks);\n      log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n      return data;\n    }),\n    startWith(getTrackReferences(room, sources, onlySubscribedTracks)),\n  );\n\n  return observable;\n}\n\nexport function participantTracksObservable(\n  participant: Participant,\n  trackIdentifier: ParticipantTrackIdentifier,\n): Observable<TrackReference[]> {\n  const observable = observeParticipantEvents(participant, ...participantTrackEvents).pipe(\n    map((participant) => {\n      const data = getParticipantTrackRefs(participant, trackIdentifier);\n      log.debug(`TrackReference[] was updated. (length ${data.length})`, data);\n      return data;\n    }),\n    startWith(getParticipantTrackRefs(participant, trackIdentifier)),\n  );\n\n  return observable;\n}\n\nexport function trackEventSelector<T extends TrackEvent>(\n  publication: TrackPublication | Track,\n  event: T,\n) {\n  const observable = new Observable<\n    Parameters<PublicationEventCallbacks[Extract<T, keyof PublicationEventCallbacks>]>\n  >((subscribe) => {\n    const update = (\n      ...params: Parameters<PublicationEventCallbacks[Extract<T, keyof PublicationEventCallbacks>]>\n    ) => {\n      subscribe.next(params);\n    };\n    // @ts-expect-error not a perfect overlap between TrackEvent and keyof TrackEventCallbacks\n    publication.on(event, update);\n\n    const unsubscribe = () => {\n      // @ts-expect-error not a perfect overlap between TrackEvent and keyof TrackEventCallbacks\n      publication.off(event, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function trackTranscriptionObserver(publication: TrackPublication) {\n  return trackEventSelector(publication, TrackEvent.TranscriptionReceived);\n}\n\nexport function trackSyncTimeObserver(track: Track) {\n  return trackEventSelector(track, TrackEvent.TimeSyncUpdate).pipe(\n    map(([timeUpdate]) => timeUpdate),\n  );\n}\n","import type { Observable } from 'rxjs';\nimport { concat, distinctUntilChanged, fromEvent, map, of, skipUntil, timeout } from 'rxjs';\n\n/**\n * Returns true if the user is interacting with the HTML element,\n * and returns false if there is no interaction for a specified period of time.\n *\n * @internal\n */\nexport function createInteractingObservable(htmlElement: HTMLElement | null, inactiveAfter = 1000) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, 'mousemove', { passive: true }).pipe(map(() => true));\n  const moveAndStop$: Observable<boolean> = move$.pipe(\n    timeout({\n      each: inactiveAfter,\n      with: () => concat(of(false), moveAndStop$.pipe(skipUntil(move$))),\n    }),\n    distinctUntilChanged(),\n  );\n  return moveAndStop$;\n}\n","import { log } from '../logger';\n\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonArray = JsonValue[];\ntype JsonObject = { [key: string]: JsonValue };\ntype JsonValue = JsonPrimitive | JsonArray | JsonObject;\n\n/**\n * Persists a serializable object to local storage associated with the specified key.\n * @internal\n */\nfunction saveToLocalStorage<T extends JsonValue>(key: string, value: T): void {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return;\n  }\n\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\n\n/**\n * Retrieves a serializable object from local storage by its key.\n * @internal\n */\nfunction loadFromLocalStorage<T extends JsonValue>(key: string): T | undefined {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return undefined;\n  }\n\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return undefined;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return undefined;\n  }\n}\n\n/**\n * Generate a pair of functions to load and save a value of type T to local storage.\n * @internal\n */\nexport function createLocalStorageInterface<T extends JsonValue>(\n  key: string,\n): { load: () => T | undefined; save: (value: T) => void } {\n  return {\n    load: () => loadFromLocalStorage<T>(key),\n    save: (value: T) => saveToLocalStorage<T>(key, value),\n  };\n}\n","import { cssPrefix } from '../constants';\nimport { createLocalStorageInterface } from './local-storage-helpers';\n\nconst USER_CHOICES_KEY = `${cssPrefix}-user-choices` as const;\n\n/**\n * @public\n * Represents the user's choices for video and audio input devices,\n * as well as their username.\n */\nexport type LocalUserChoices = {\n  /**\n   * Whether video input is enabled.\n   * @defaultValue `true`\n   */\n  videoEnabled: boolean;\n  /**\n   * Whether audio input is enabled.\n   * @defaultValue `true`\n   */\n  audioEnabled: boolean;\n  /**\n   * The device ID of the video input device to use.\n   * @defaultValue `''`\n   */\n  videoDeviceId: string;\n  /**\n   * The device ID of the audio input device to use.\n   * @defaultValue `''`\n   */\n  audioDeviceId: string;\n  /**\n   * The username to use.\n   * @defaultValue `''`\n   */\n  username: string;\n};\n\nexport const defaultUserChoices: LocalUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: '',\n  audioDeviceId: '',\n  username: '',\n} as const;\n\n/**\n * The type of the object stored in local storage.\n * @remarks\n * TODO: Replace this type with `LocalUserChoices` after removing the deprecated properties from `LocalUserChoices`.\n * @internal\n */\ntype TempStorageType = Omit<LocalUserChoices, 'e2ee' | 'sharedPassphrase'>;\nconst { load, save } = createLocalStorageInterface<TempStorageType>(USER_CHOICES_KEY);\n\n/**\n * Saves user choices to local storage.\n * @alpha\n */\nexport function saveUserChoices(\n  userChoices: LocalUserChoices,\n  /**\n   * Whether to prevent saving user choices to local storage.\n   */\n  preventSave: boolean = false,\n): void {\n  if (preventSave === true) {\n    return;\n  }\n  save(userChoices);\n}\n\n/**\n * Reads the user choices from local storage, or returns the default settings if none are found.\n * @remarks\n * The deprecated parameters `e2ee` and `sharedPassphrase` are not read from local storage\n * and always return the value from the passed `defaults` or internal defaults.\n * @alpha\n */\nexport function loadUserChoices(\n  defaults?: Partial<LocalUserChoices>,\n  /**\n   * Whether to prevent loading from local storage and return default values instead.\n   * @defaultValue false\n   */\n  preventLoad: boolean = false,\n): LocalUserChoices {\n  const fallback: LocalUserChoices = {\n    videoEnabled: defaults?.videoEnabled ?? defaultUserChoices.videoEnabled,\n    audioEnabled: defaults?.audioEnabled ?? defaultUserChoices.audioEnabled,\n    videoDeviceId: defaults?.videoDeviceId ?? defaultUserChoices.videoDeviceId,\n    audioDeviceId: defaults?.audioDeviceId ?? defaultUserChoices.audioDeviceId,\n    username: defaults?.username ?? defaultUserChoices.username,\n  };\n\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = { ...fallback, ...(maybeLoadedObject ?? {}) };\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}