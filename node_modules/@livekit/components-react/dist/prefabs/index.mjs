var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/prefabs/Chat.tsx
import * as React81 from "react";

// src/context/layout-context.ts
import { PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE } from "@livekit/components-core";
import * as React from "react";

// src/context/chat-context.ts
function chatReducer(state, action) {
  if (action.msg === "show_chat") {
    return __spreadProps(__spreadValues({}, state), { showChat: true, unreadMessages: 0 });
  } else if (action.msg === "hide_chat") {
    return __spreadProps(__spreadValues({}, state), { showChat: false });
  } else if (action.msg === "toggle_chat") {
    const newState = __spreadProps(__spreadValues({}, state), { showChat: !state.showChat });
    if (newState.showChat === true) {
      newState.unreadMessages = 0;
    }
    return newState;
  } else if (action.msg === "unread_msg") {
    return __spreadProps(__spreadValues({}, state), { unreadMessages: action.count });
  } else if (action.msg === "toggle_settings") {
    return __spreadProps(__spreadValues({}, state), { showSettings: !state.showSettings });
  } else {
    return __spreadValues({}, state);
  }
}

// src/context/pin-context.ts
function pinReducer(state, action) {
  if (action.msg === "set_pin") {
    return [action.trackReference];
  } else if (action.msg === "clear_pin") {
    return [];
  } else {
    return __spreadValues({}, state);
  }
}

// src/context/layout-context.ts
var LayoutContext = React.createContext(void 0);
function useLayoutContext() {
  const layoutContext = React.useContext(LayoutContext);
  if (!layoutContext) {
    throw Error("Tried to access LayoutContext context outside a LayoutContextProvider provider.");
  }
  return layoutContext;
}
function useEnsureLayoutContext(layoutContext) {
  const layout = useMaybeLayoutContext();
  layoutContext != null ? layoutContext : layoutContext = layout;
  if (!layoutContext) {
    throw Error("Tried to access LayoutContext context outside a LayoutContextProvider provider.");
  }
  return layoutContext;
}
function useCreateLayoutContext() {
  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);
  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);
  return {
    pin: { dispatch: pinDispatch, state: pinState },
    widget: { dispatch: widgetDispatch, state: widgetState }
  };
}
function useEnsureCreateLayoutContext(layoutContext) {
  const [pinState, pinDispatch] = React.useReducer(pinReducer, PIN_DEFAULT_STATE);
  const [widgetState, widgetDispatch] = React.useReducer(chatReducer, WIDGET_DEFAULT_STATE);
  return layoutContext != null ? layoutContext : {
    pin: { dispatch: pinDispatch, state: pinState },
    widget: { dispatch: widgetDispatch, state: widgetState }
  };
}
function useMaybeLayoutContext() {
  return React.useContext(LayoutContext);
}

// src/context/participant-context.ts
import * as React3 from "react";

// src/context/track-reference-context.ts
import * as React2 from "react";
var TrackRefContext = React2.createContext(
  void 0
);
function useMaybeTrackRefContext() {
  return React2.useContext(TrackRefContext);
}
function useEnsureTrackRef(trackRef) {
  const context = useMaybeTrackRefContext();
  const ref = trackRef != null ? trackRef : context;
  if (!ref) {
    throw new Error(
      "No TrackRef, make sure you are inside a TrackRefContext or pass the TrackRef explicitly"
    );
  }
  return ref;
}

// src/context/participant-context.ts
var ParticipantContext = React3.createContext(void 0);
function useMaybeParticipantContext() {
  return React3.useContext(ParticipantContext);
}
function useEnsureParticipant(participant) {
  var _a;
  const context = useMaybeParticipantContext();
  const trackContext = useMaybeTrackRefContext();
  const p = (_a = participant != null ? participant : context) != null ? _a : trackContext == null ? void 0 : trackContext.participant;
  if (!p) {
    throw new Error(
      "No participant provided, make sure you are inside a participant context or pass the participant explicitly"
    );
  }
  return p;
}

// src/context/room-context.ts
import * as React4 from "react";
var RoomContext = React4.createContext(void 0);
function useRoomContext() {
  const ctx = React4.useContext(RoomContext);
  if (!ctx) {
    throw Error("tried to access room context outside of livekit room component");
  }
  return ctx;
}
function useMaybeRoomContext() {
  return React4.useContext(RoomContext);
}
function useEnsureRoom(room) {
  const context = useMaybeRoomContext();
  const r = room != null ? room : context;
  if (!r) {
    throw new Error(
      "No room provided, make sure you are inside a Room context or pass the room explicitly"
    );
  }
  return r;
}

// src/context/feature-context.ts
import * as React5 from "react";
var LKFeatureContext = React5.createContext(void 0);
function useFeatureContext(require2) {
  const ctx = React5.useContext(LKFeatureContext);
  if (require2 === true) {
    if (ctx) {
      return ctx;
    } else {
      throw Error("tried to access feature context, but none is present");
    }
  }
  return ctx;
}

// src/utils.ts
import * as React6 from "react";

// src/mergeProps.ts
import clsx from "clsx";
function chain(...callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function") {
        try {
          callback(...args);
        } catch (e) {
          console.error(e);
        }
      }
    }
  };
}
function mergeProps(...args) {
  const result = __spreadValues({}, args[0]);
  for (let i = 1; i < args.length; i++) {
    const props = args[i];
    for (const key in props) {
      const a = result[key];
      const b = props[key];
      if (typeof a === "function" && typeof b === "function" && // This is a lot faster than a regex.
      key[0] === "o" && key[1] === "n" && key.charCodeAt(2) >= /* 'A' */
      65 && key.charCodeAt(2) <= /* 'Z' */
      90) {
        result[key] = chain(a, b);
      } else if ((key === "className" || key === "UNSAFE_className") && typeof a === "string" && typeof b === "string") {
        result[key] = clsx(a, b);
      } else {
        result[key] = b !== void 0 ? b : a;
      }
    }
  }
  return result;
}

// src/utils.ts
import { log } from "@livekit/components-core";
function isProp(prop) {
  return prop !== void 0;
}
function mergeProps2(...props) {
  return mergeProps(...props.filter(isProp));
}
function cloneSingleChild(children, props, key) {
  return React6.Children.map(children, (child) => {
    if (React6.isValidElement(child) && React6.Children.only(children)) {
      return React6.cloneElement(child, __spreadProps(__spreadValues({}, props), { key }));
    }
    return child;
  });
}
function warnAboutMissingStyles(el) {
  var _a, _b;
  if (typeof window !== "undefined" && typeof process !== "undefined" && // eslint-disable-next-line turbo/no-undeclared-env-vars
  (((_a = process == null ? void 0 : process.env) == null ? void 0 : _a.NODE_ENV) === "dev" || // eslint-disable-next-line turbo/no-undeclared-env-vars
  ((_b = process == null ? void 0 : process.env) == null ? void 0 : _b.NODE_ENV) === "development")) {
    const target = el != null ? el : document.querySelector(".lk-room-container");
    if (target && !getComputedStyle(target).getPropertyValue("--lk-has-imported-styles")) {
      log.warn(
        "It looks like you're not using the `@livekit/components-styles package`. To render the UI with the default styling, please import it in your layout or page."
      );
    }
  }
}

// src/components/ChatEntry.tsx
import { tokenize, createDefaultGrammar } from "@livekit/components-core";
import * as React7 from "react";
var ChatEntry = /* @__PURE__ */ React7.forwardRef(
  function ChatEntry2(_a, ref) {
    var _b = _a, { entry, hideName = false, hideTimestamp = false, messageFormatter } = _b, props = __objRest(_b, ["entry", "hideName", "hideTimestamp", "messageFormatter"]);
    var _a2, _b2, _c, _d;
    const formattedMessage = React7.useMemo(() => {
      return messageFormatter ? messageFormatter(entry.message) : entry.message;
    }, [entry.message, messageFormatter]);
    const hasBeenEdited = !!entry.editTimestamp;
    const time = new Date(entry.timestamp);
    const locale = navigator ? navigator.language : "en-US";
    return /* @__PURE__ */ React7.createElement(
      "li",
      __spreadValues({
        ref,
        className: "lk-chat-entry",
        title: time.toLocaleTimeString(locale, { timeStyle: "full" }),
        "data-lk-message-origin": ((_a2 = entry.from) == null ? void 0 : _a2.isLocal) ? "local" : "remote"
      }, props),
      (!hideTimestamp || !hideName || hasBeenEdited) && /* @__PURE__ */ React7.createElement("span", { className: "lk-meta-data" }, !hideName && /* @__PURE__ */ React7.createElement("strong", { className: "lk-participant-name" }, (_d = (_b2 = entry.from) == null ? void 0 : _b2.name) != null ? _d : (_c = entry.from) == null ? void 0 : _c.identity), (!hideTimestamp || hasBeenEdited) && /* @__PURE__ */ React7.createElement("span", { className: "lk-timestamp" }, hasBeenEdited && "edited ", time.toLocaleTimeString(locale, { timeStyle: "short" }))),
      /* @__PURE__ */ React7.createElement("span", { className: "lk-message-body" }, formattedMessage)
    );
  }
);

// src/hooks/useChat.ts
import * as React12 from "react";
import { setupChat } from "@livekit/components-core";
import { ConnectionState } from "livekit-client";

// src/hooks/internal/useObservableState.ts
import * as React8 from "react";
function useObservableState(observable, startWith, resetWhenObservableChanges = true) {
  const [state, setState] = React8.useState(startWith);
  React8.useEffect(() => {
    if (resetWhenObservableChanges) {
      setState(startWith);
    }
    if (typeof window === "undefined" || !observable) return;
    const subscription = observable.subscribe(setState);
    return () => subscription.unsubscribe();
  }, [observable, resetWhenObservableChanges]);
  return state;
}

// src/hooks/useConnectionStatus.ts
import { connectionStateObserver } from "@livekit/components-core";
import * as React11 from "react";

// src/hooks/internal/useResizeObserver.ts
import * as React9 from "react";
import useLatest from "@react-hook/latest";
function useResizeObserver(target, callback) {
  const resizeObserver = getResizeObserver();
  const storedCallback = useLatest(callback);
  React9.useLayoutEffect(() => {
    let didUnsubscribe = false;
    const targetEl = target.current;
    if (!targetEl) return;
    function cb(entry, observer) {
      if (didUnsubscribe) return;
      storedCallback.current(entry, observer);
    }
    resizeObserver == null ? void 0 : resizeObserver.subscribe(targetEl, cb);
    return () => {
      didUnsubscribe = true;
      resizeObserver == null ? void 0 : resizeObserver.unsubscribe(targetEl, cb);
    };
  }, [target.current, resizeObserver, storedCallback]);
  return resizeObserver == null ? void 0 : resizeObserver.observer;
}
function createResizeObserver() {
  let ticking = false;
  let allEntries = [];
  const callbacks = /* @__PURE__ */ new Map();
  if (typeof window === "undefined") {
    return;
  }
  const observer = new ResizeObserver((entries, obs) => {
    allEntries = allEntries.concat(entries);
    if (!ticking) {
      window.requestAnimationFrame(() => {
        const triggered = /* @__PURE__ */ new Set();
        for (let i = 0; i < allEntries.length; i++) {
          if (triggered.has(allEntries[i].target)) continue;
          triggered.add(allEntries[i].target);
          const cbs = callbacks.get(allEntries[i].target);
          cbs == null ? void 0 : cbs.forEach((cb) => cb(allEntries[i], obs));
        }
        allEntries = [];
        ticking = false;
      });
    }
    ticking = true;
  });
  return {
    observer,
    subscribe(target, callback) {
      var _a;
      observer.observe(target);
      const cbs = (_a = callbacks.get(target)) != null ? _a : [];
      cbs.push(callback);
      callbacks.set(target, cbs);
    },
    unsubscribe(target, callback) {
      var _a;
      const cbs = (_a = callbacks.get(target)) != null ? _a : [];
      if (cbs.length === 1) {
        observer.unobserve(target);
        callbacks.delete(target);
        return;
      }
      const cbIndex = cbs.indexOf(callback);
      if (cbIndex !== -1) cbs.splice(cbIndex, 1);
      callbacks.set(target, cbs);
    }
  };
}
var _resizeObserver;
var getResizeObserver = () => !_resizeObserver ? _resizeObserver = createResizeObserver() : _resizeObserver;
var useSize = (target) => {
  const [size, setSize] = React9.useState({ width: 0, height: 0 });
  React9.useLayoutEffect(() => {
    if (target.current) {
      const { width, height } = target.current.getBoundingClientRect();
      setSize({ width, height });
    }
  }, [target.current]);
  const resizeCallback = React9.useCallback(
    (entry) => setSize(entry.contentRect),
    []
  );
  useResizeObserver(target, resizeCallback);
  return size;
};

// src/hooks/internal/useMediaQuery.ts
import * as React10 from "react";
function useMediaQuery(query) {
  const getMatches = (query2) => {
    if (typeof window !== "undefined") {
      return window.matchMedia(query2).matches;
    }
    return false;
  };
  const [matches, setMatches] = React10.useState(getMatches(query));
  function handleChange() {
    setMatches(getMatches(query));
  }
  React10.useEffect(() => {
    const matchMedia = window.matchMedia(query);
    handleChange();
    if (matchMedia.addListener) {
      matchMedia.addListener(handleChange);
    } else {
      matchMedia.addEventListener("change", handleChange);
    }
    return () => {
      if (matchMedia.removeListener) {
        matchMedia.removeListener(handleChange);
      } else {
        matchMedia.removeEventListener("change", handleChange);
      }
    };
  }, [query]);
  return matches;
}

// src/hooks/useConnectionStatus.ts
function useConnectionState(room) {
  const r = useEnsureRoom(room);
  const observable = React11.useMemo(() => connectionStateObserver(r), [r]);
  const connectionState = useObservableState(observable, r.state);
  return connectionState;
}

// src/hooks/useChat.ts
function useChat(options) {
  const room = useRoomContext();
  const connectionState = useConnectionState(room);
  const isDisconnected = React12.useMemo(
    () => connectionState === ConnectionState.Disconnected,
    [connectionState]
  );
  const setup = React12.useMemo(
    () => setupChat(room, options),
    [room, options, isDisconnected]
  );
  const isSending = useObservableState(setup.isSendingObservable, false);
  const chatMessages = useObservableState(setup.messageObservable, []);
  return { send: setup.send, update: setup.update, chatMessages, isSending };
}

// src/hooks/useConnectionQualityIndicator.ts
import { setupConnectionQualityIndicator } from "@livekit/components-core";
import { ConnectionQuality } from "livekit-client";
import * as React13 from "react";
function useConnectionQualityIndicator(options = {}) {
  const p = useEnsureParticipant(options.participant);
  const { className, connectionQualityObserver } = React13.useMemo(
    () => setupConnectionQualityIndicator(p),
    [p]
  );
  const quality = useObservableState(connectionQualityObserver, ConnectionQuality.Unknown);
  return { className, quality };
}

// src/hooks/useDisconnectButton.ts
import { setupDisconnectButton } from "@livekit/components-core";
import { ConnectionState as ConnectionState2 } from "livekit-client";
import * as React14 from "react";
function useDisconnectButton(props) {
  const room = useRoomContext();
  const connectionState = useConnectionState(room);
  const buttonProps = React14.useMemo(() => {
    const { className, disconnect } = setupDisconnectButton(room);
    const mergedProps = mergeProps(props, {
      className,
      onClick: () => {
        var _a;
        return disconnect((_a = props.stopTracks) != null ? _a : true);
      },
      disabled: connectionState === ConnectionState2.Disconnected
    });
    return mergedProps;
  }, [room, props, connectionState]);
  return { buttonProps };
}

// src/hooks/useFacingMode.ts
import { LocalTrackPublication, facingModeFromLocalTrack } from "livekit-client";
function useFacingMode(trackReference) {
  if (trackReference.publication instanceof LocalTrackPublication) {
    const localTrack = trackReference.publication.track;
    if (localTrack) {
      const { facingMode } = facingModeFromLocalTrack(localTrack);
      return facingMode;
    }
  }
  return "undefined";
}

// src/hooks/useFocusToggle.ts
import { setupFocusToggle, isTrackReferencePinned } from "@livekit/components-core";
import * as React15 from "react";
function useFocusToggle({ trackRef, props }) {
  const trackReference = useEnsureTrackRef(trackRef);
  const layoutContext = useMaybeLayoutContext();
  const { className } = React15.useMemo(() => setupFocusToggle(), []);
  const inFocus = React15.useMemo(() => {
    return isTrackReferencePinned(trackReference, layoutContext == null ? void 0 : layoutContext.pin.state);
  }, [trackReference, layoutContext == null ? void 0 : layoutContext.pin.state]);
  const mergedProps = React15.useMemo(
    () => mergeProps(props, {
      className,
      onClick: (event) => {
        var _a, _b, _c, _d, _e;
        (_a = props.onClick) == null ? void 0 : _a.call(props, event);
        if (inFocus) {
          (_c = layoutContext == null ? void 0 : (_b = layoutContext.pin).dispatch) == null ? void 0 : _c.call(_b, {
            msg: "clear_pin"
          });
        } else {
          (_e = layoutContext == null ? void 0 : (_d = layoutContext.pin).dispatch) == null ? void 0 : _e.call(_d, {
            msg: "set_pin",
            trackReference
          });
        }
      }
    }),
    [props, className, trackReference, inFocus, layoutContext == null ? void 0 : layoutContext.pin]
  );
  return { mergedProps, inFocus };
}

// src/hooks/useGridLayout.ts
import { GRID_LAYOUTS, selectGridLayout } from "@livekit/components-core";
import * as React16 from "react";
function useGridLayout(gridElement, trackCount) {
  const { width, height } = useSize(gridElement);
  const layout = width > 0 && height > 0 ? selectGridLayout(GRID_LAYOUTS, trackCount, width, height) : GRID_LAYOUTS[0];
  React16.useEffect(() => {
    if (gridElement.current && layout) {
      gridElement.current.style.setProperty("--lk-col-count", layout == null ? void 0 : layout.columns.toString());
      gridElement.current.style.setProperty("--lk-row-count", layout == null ? void 0 : layout.rows.toString());
    }
  }, [gridElement, layout]);
  return {
    layout
  };
}

// src/hooks/useIsMuted.ts
import {
  getTrackReferenceId,
  mutedObserver
} from "@livekit/components-core";
import * as React17 from "react";
function useIsMuted(sourceOrTrackRef, options = {}) {
  var _a, _b;
  const passedParticipant = typeof sourceOrTrackRef === "string" ? options.participant : sourceOrTrackRef.participant;
  const p = useEnsureParticipant(passedParticipant);
  const ref = typeof sourceOrTrackRef === "string" ? { participant: p, source: sourceOrTrackRef } : sourceOrTrackRef;
  const [isMuted, setIsMuted] = React17.useState(
    !!(((_a = ref.publication) == null ? void 0 : _a.isMuted) || ((_b = p.getTrackPublication(ref.source)) == null ? void 0 : _b.isMuted))
  );
  React17.useEffect(() => {
    const listener = mutedObserver(ref).subscribe(setIsMuted);
    return () => listener.unsubscribe();
  }, [getTrackReferenceId(ref)]);
  return isMuted;
}

// src/hooks/useIsSpeaking.ts
import { createIsSpeakingObserver } from "@livekit/components-core";
import * as React18 from "react";
function useIsSpeaking(participant) {
  const p = useEnsureParticipant(participant);
  const observable = React18.useMemo(() => createIsSpeakingObserver(p), [p]);
  const isSpeaking = useObservableState(observable, p.isSpeaking);
  return isSpeaking;
}

// src/hooks/useLocalParticipantPermissions.ts
import { participantPermissionObserver } from "@livekit/components-core";
import * as React19 from "react";
function useLocalParticipantPermissions() {
  const room = useRoomContext();
  const permissionObserver = React19.useMemo(
    () => participantPermissionObserver(room.localParticipant),
    [room]
  );
  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);
  return permissions;
}

// src/hooks/useMediaDeviceSelect.ts
import { createMediaDeviceObserver, setupDeviceSelector, log as log2 } from "@livekit/components-core";
import * as React20 from "react";
function useMediaDeviceSelect({
  kind,
  room,
  track,
  requestPermissions,
  onError
}) {
  const roomContext = useMaybeRoomContext();
  const deviceObserver = React20.useMemo(
    () => createMediaDeviceObserver(kind, onError, requestPermissions),
    [kind, requestPermissions, onError]
  );
  const devices = useObservableState(deviceObserver, []);
  const [currentDeviceId, setCurrentDeviceId] = React20.useState("");
  const { className, activeDeviceObservable, setActiveMediaDevice } = React20.useMemo(
    () => setupDeviceSelector(kind, room != null ? room : roomContext, track),
    [kind, room, roomContext, track]
  );
  React20.useEffect(() => {
    const listener = activeDeviceObservable.subscribe((deviceId) => {
      log2.info("setCurrentDeviceId", deviceId);
      if (deviceId) setCurrentDeviceId(deviceId);
    });
    return () => {
      listener == null ? void 0 : listener.unsubscribe();
    };
  }, [activeDeviceObservable]);
  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };
}

// src/hooks/useMediaDevices.ts
import * as React21 from "react";
import { createMediaDeviceObserver as createMediaDeviceObserver2 } from "@livekit/components-core";
function useMediaDevices({
  kind,
  onError
}) {
  const deviceObserver = React21.useMemo(
    () => createMediaDeviceObserver2(kind, onError),
    [kind, onError]
  );
  const devices = useObservableState(deviceObserver, []);
  return devices;
}

// src/hooks/usePagination.ts
import * as React23 from "react";

// src/hooks/useVisualStableUpdate.ts
import { log as log3, sortTrackReferences, updatePages } from "@livekit/components-core";
import * as React22 from "react";
function useVisualStableUpdate(trackReferences, maxItemsOnPage, options = {}) {
  const lastTrackRefs = React22.useRef([]);
  const lastMaxItemsOnPage = React22.useRef(-1);
  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;
  const sortedTrackRefs = typeof options.customSortFunction === "function" ? options.customSortFunction(trackReferences) : sortTrackReferences(trackReferences);
  let updatedTrackRefs = [...sortedTrackRefs];
  if (layoutChanged === false) {
    try {
      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);
    } catch (error) {
      log3.error("Error while running updatePages(): ", error);
    }
  }
  if (layoutChanged) {
    lastTrackRefs.current = sortedTrackRefs;
  } else {
    lastTrackRefs.current = updatedTrackRefs;
  }
  lastMaxItemsOnPage.current = maxItemsOnPage;
  return updatedTrackRefs;
}

// src/hooks/usePagination.ts
function usePagination(itemPerPage, trackReferences) {
  const [currentPage, setCurrentPage] = React23.useState(1);
  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);
  if (currentPage > totalPageCount) {
    setCurrentPage(totalPageCount);
  }
  const lastItemIndex = currentPage * itemPerPage;
  const firstItemIndex = lastItemIndex - itemPerPage;
  const changePage = (direction) => {
    setCurrentPage((state) => {
      if (direction === "next") {
        if (state === totalPageCount) {
          return state;
        }
        return state + 1;
      } else {
        if (state === 1) {
          return state;
        }
        return state - 1;
      }
    });
  };
  const goToPage = (num) => {
    if (num > totalPageCount) {
      setCurrentPage(totalPageCount);
    } else if (num < 1) {
      setCurrentPage(1);
    } else {
      setCurrentPage(num);
    }
  };
  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);
  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);
  return {
    totalPageCount,
    nextPage: () => changePage("next"),
    prevPage: () => changePage("previous"),
    setPage: goToPage,
    firstItemIndex,
    lastItemIndex,
    tracks: tracksOnPage,
    currentPage
  };
}

// src/hooks/useParticipantTile.ts
import { setupParticipantTile } from "@livekit/components-core";
import * as React24 from "react";
import { Track } from "livekit-client";
function useParticipantTile({
  trackRef,
  onParticipantClick,
  disableSpeakingIndicator,
  htmlProps
}) {
  const trackReference = useEnsureTrackRef(trackRef);
  const mergedProps = React24.useMemo(() => {
    const { className } = setupParticipantTile();
    return mergeProps(htmlProps, {
      className,
      onClick: (event) => {
        var _a, _b;
        (_a = htmlProps.onClick) == null ? void 0 : _a.call(htmlProps, event);
        if (typeof onParticipantClick === "function") {
          const track = (_b = trackReference.publication) != null ? _b : trackReference.participant.getTrackPublication(trackReference.source);
          onParticipantClick({ participant: trackReference.participant, track });
        }
      }
    });
  }, [
    htmlProps,
    onParticipantClick,
    trackReference.publication,
    trackReference.source,
    trackReference.participant
  ]);
  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);
  const micRef = React24.useMemo(() => {
    return {
      participant: trackReference.participant,
      source: Track.Source.Microphone,
      publication: micTrack
    };
  }, [micTrack, trackReference.participant]);
  const isVideoMuted = useIsMuted(trackReference);
  const isAudioMuted = useIsMuted(micRef);
  const isSpeaking = useIsSpeaking(trackReference.participant);
  const facingMode = useFacingMode(trackReference);
  return {
    elementProps: __spreadValues({
      "data-lk-audio-muted": isAudioMuted,
      "data-lk-video-muted": isVideoMuted,
      "data-lk-speaking": disableSpeakingIndicator === true ? false : isSpeaking,
      "data-lk-local-participant": trackReference.participant.isLocal,
      "data-lk-source": trackReference.source,
      "data-lk-facing-mode": facingMode
    }, mergedProps)
  };
}

// src/hooks/usePinnedTracks.ts
import * as React25 from "react";
function usePinnedTracks(layoutContext) {
  layoutContext = useEnsureLayoutContext(layoutContext);
  return React25.useMemo(() => {
    if ((layoutContext == null ? void 0 : layoutContext.pin.state) !== void 0 && layoutContext.pin.state.length >= 1) {
      return layoutContext.pin.state;
    }
    return [];
  }, [layoutContext.pin.state]);
}

// src/hooks/useStartAudio.ts
import { setupStartAudio } from "@livekit/components-core";
import * as React26 from "react";
function useStartAudio({ room, props }) {
  const roomEnsured = useEnsureRoom(room);
  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React26.useMemo(
    () => setupStartAudio(),
    []
  );
  const observable = React26.useMemo(
    () => roomAudioPlaybackAllowedObservable(roomEnsured),
    [roomEnsured, roomAudioPlaybackAllowedObservable]
  );
  const { canPlayAudio } = useObservableState(observable, {
    canPlayAudio: roomEnsured.canPlaybackAudio
  });
  const mergedProps = React26.useMemo(
    () => mergeProps(props, {
      className,
      onClick: () => {
        handleStartAudioPlayback(roomEnsured);
      },
      style: { display: canPlayAudio ? "none" : "block" }
    }),
    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured]
  );
  return { mergedProps, canPlayAudio };
}

// src/hooks/useStartVideo.ts
import { setupStartVideo } from "@livekit/components-core";
import * as React27 from "react";
function useStartVideo({ room, props }) {
  const roomEnsured = useEnsureRoom(room);
  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React27.useMemo(
    () => setupStartVideo(),
    []
  );
  const observable = React27.useMemo(
    () => roomVideoPlaybackAllowedObservable(roomEnsured),
    [roomEnsured, roomVideoPlaybackAllowedObservable]
  );
  const { canPlayVideo } = useObservableState(observable, {
    canPlayVideo: roomEnsured.canPlaybackVideo
  });
  const mergedProps = React27.useMemo(
    () => mergeProps(props, {
      className,
      onClick: () => {
        handleStartVideoPlayback(roomEnsured);
      },
      style: { display: canPlayVideo ? "none" : "block" }
    }),
    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured]
  );
  return { mergedProps, canPlayVideo };
}

// src/hooks/useSwipe.ts
import * as React28 from "react";
function useSwipe(element, options = {}) {
  var _a;
  const touchStart = React28.useRef(null);
  const touchEnd = React28.useRef(null);
  const minSwipeDistance = (_a = options.minSwipeDistance) != null ? _a : 50;
  const onTouchStart = (event) => {
    touchEnd.current = null;
    touchStart.current = event.targetTouches[0].clientX;
  };
  const onTouchMove = (event) => {
    touchEnd.current = event.targetTouches[0].clientX;
  };
  const onTouchEnd = React28.useCallback(() => {
    if (!touchStart.current || !touchEnd.current) {
      return;
    }
    const distance = touchStart.current - touchEnd.current;
    const isLeftSwipe = distance > minSwipeDistance;
    const isRightSwipe = distance < -minSwipeDistance;
    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();
    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();
  }, [minSwipeDistance, options]);
  React28.useEffect(() => {
    const elementCopy = element.current;
    if (elementCopy) {
      elementCopy.addEventListener("touchstart", onTouchStart, { passive: true });
      elementCopy.addEventListener("touchmove", onTouchMove, { passive: true });
      elementCopy.addEventListener("touchend", onTouchEnd, { passive: true });
    }
    return () => {
      if (elementCopy) {
        elementCopy.removeEventListener("touchstart", onTouchStart);
        elementCopy.removeEventListener("touchmove", onTouchMove);
        elementCopy.removeEventListener("touchend", onTouchEnd);
      }
    };
  }, [element, onTouchEnd]);
}

// src/hooks/useChatToggle.ts
import { setupChatToggle } from "@livekit/components-core";
import * as React29 from "react";
function useChatToggle({ props }) {
  const { dispatch, state } = useLayoutContext().widget;
  const { className } = React29.useMemo(() => setupChatToggle(), []);
  const mergedProps = React29.useMemo(() => {
    return mergeProps(props, {
      className,
      onClick: () => {
        if (dispatch) dispatch({ msg: "toggle_chat" });
      },
      "aria-pressed": (state == null ? void 0 : state.showChat) ? "true" : "false",
      "data-lk-unread-msgs": state ? state.unreadMessages < 10 ? state.unreadMessages.toFixed(0) : "9+" : "0"
    });
  }, [props, className, dispatch, state]);
  return { mergedProps };
}

// src/hooks/useTrackMutedIndicator.ts
import {
  setupTrackMutedIndicator,
  getTrackReferenceId as getTrackReferenceId2
} from "@livekit/components-core";
import * as React30 from "react";
function useTrackMutedIndicator(trackRef) {
  var _a, _b;
  const trackReference = useEnsureTrackRef(trackRef);
  const { className, mediaMutedObserver } = React30.useMemo(
    () => setupTrackMutedIndicator(trackReference),
    [getTrackReferenceId2(trackReference)]
  );
  const isMuted = useObservableState(
    mediaMutedObserver,
    !!(((_a = trackReference.publication) == null ? void 0 : _a.isMuted) || ((_b = trackReference.participant.getTrackPublication(trackReference.source)) == null ? void 0 : _b.isMuted))
  );
  return { isMuted, className };
}

// src/hooks/useTrackToggle.ts
import { setupMediaToggle, setupManualToggle, log as log4 } from "@livekit/components-core";
import * as React31 from "react";
function useTrackToggle(_a) {
  var _b = _a, {
    source,
    onChange,
    initialState,
    captureOptions,
    publishOptions,
    onDeviceError
  } = _b, rest = __objRest(_b, [
    "source",
    "onChange",
    "initialState",
    "captureOptions",
    "publishOptions",
    "onDeviceError"
  ]);
  var _a2;
  const room = useMaybeRoomContext();
  const track = (_a2 = room == null ? void 0 : room.localParticipant) == null ? void 0 : _a2.getTrackPublication(source);
  const userInteractionRef = React31.useRef(false);
  const { toggle, className, pendingObserver, enabledObserver } = React31.useMemo(
    () => room ? setupMediaToggle(source, room, captureOptions, publishOptions, onDeviceError) : setupManualToggle(),
    [room, source, JSON.stringify(captureOptions), publishOptions]
  );
  const pending = useObservableState(pendingObserver, false);
  const enabled = useObservableState(enabledObserver, initialState != null ? initialState : !!(track == null ? void 0 : track.isEnabled));
  React31.useEffect(() => {
    onChange == null ? void 0 : onChange(enabled, userInteractionRef.current);
    userInteractionRef.current = false;
  }, [enabled, onChange]);
  React31.useEffect(() => {
    if (initialState !== void 0) {
      log4.debug("forcing initial toggle state", source, initialState);
      toggle(initialState);
    }
  }, []);
  const newProps = React31.useMemo(() => mergeProps(rest, { className }), [rest, className]);
  const clickHandler = React31.useCallback(
    (evt) => {
      var _a3;
      userInteractionRef.current = true;
      toggle().finally(() => userInteractionRef.current = false);
      (_a3 = rest.onClick) == null ? void 0 : _a3.call(rest, evt);
    },
    [rest, toggle]
  );
  return {
    toggle,
    enabled,
    pending,
    track,
    buttonProps: __spreadProps(__spreadValues({}, newProps), {
      "aria-pressed": enabled,
      "data-lk-source": source,
      "data-lk-enabled": enabled,
      disabled: pending,
      onClick: clickHandler
    })
  };
}

// src/hooks/useTracks.ts
import {
  isSourcesWithOptions,
  isSourceWitOptions,
  log as log5,
  trackReferencesObservable
} from "@livekit/components-core";
import { Track as Track2 } from "livekit-client";
import * as React32 from "react";
function useTracks(sources = [
  Track2.Source.Camera,
  Track2.Source.Microphone,
  Track2.Source.ScreenShare,
  Track2.Source.ScreenShareAudio,
  Track2.Source.Unknown
], options = {}) {
  const room = useEnsureRoom(options.room);
  const [trackReferences, setTrackReferences] = React32.useState([]);
  const [participants, setParticipants] = React32.useState([]);
  const sources_ = React32.useMemo(() => {
    return sources.map((s) => isSourceWitOptions(s) ? s.source : s);
  }, [JSON.stringify(sources)]);
  React32.useEffect(() => {
    const subscription = trackReferencesObservable(room, sources_, {
      additionalRoomEvents: options.updateOnlyOn,
      onlySubscribed: options.onlySubscribed
    }).subscribe(({ trackReferences: trackReferences2, participants: participants2 }) => {
      log5.debug("setting track bundles", trackReferences2, participants2);
      setTrackReferences(trackReferences2);
      setParticipants(participants2);
    });
    return () => subscription.unsubscribe();
  }, [
    room,
    JSON.stringify(options.onlySubscribed),
    JSON.stringify(options.updateOnlyOn),
    JSON.stringify(sources)
  ]);
  const maybeTrackReferences = React32.useMemo(() => {
    if (isSourcesWithOptions(sources)) {
      const requirePlaceholder = requiredPlaceholders(sources, participants);
      const trackReferencesWithPlaceholders = Array.from(trackReferences);
      participants.forEach((participant) => {
        var _a;
        if (requirePlaceholder.has(participant.identity)) {
          const sourcesToAddPlaceholder = (_a = requirePlaceholder.get(participant.identity)) != null ? _a : [];
          sourcesToAddPlaceholder.forEach((placeholderSource) => {
            if (trackReferences.find(
              ({ participant: p, publication }) => participant.identity === p.identity && publication.source === placeholderSource
            )) {
              return;
            }
            log5.debug(
              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`
            );
            const placeholder = {
              participant,
              source: placeholderSource
            };
            trackReferencesWithPlaceholders.push(placeholder);
          });
        }
      });
      return trackReferencesWithPlaceholders;
    } else {
      return trackReferences;
    }
  }, [trackReferences, participants, sources]);
  return maybeTrackReferences;
}
function difference(setA, setB) {
  const _difference = new Set(setA);
  for (const elem of setB) {
    _difference.delete(elem);
  }
  return _difference;
}
function requiredPlaceholders(sources, participants) {
  const placeholderMap = /* @__PURE__ */ new Map();
  if (isSourcesWithOptions(sources)) {
    const sourcesThatNeedPlaceholder = sources.filter((sourceWithOption) => sourceWithOption.withPlaceholder).map((sourceWithOption) => sourceWithOption.source);
    participants.forEach((participant) => {
      const sourcesOfSubscribedTracks = participant.getTrackPublications().map((pub) => {
        var _a;
        return (_a = pub.track) == null ? void 0 : _a.source;
      }).filter((trackSource) => trackSource !== void 0);
      const placeholderNeededForThisParticipant = Array.from(
        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks))
      );
      if (placeholderNeededForThisParticipant.length > 0) {
        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);
      }
    });
  }
  return placeholderMap;
}

// src/hooks/usePersistentUserChoices.ts
import { loadUserChoices, saveUserChoices } from "@livekit/components-core";
import * as React33 from "react";
function usePersistentUserChoices(options = {}) {
  var _a;
  const [userChoices, setSettings] = React33.useState(
    loadUserChoices(options.defaults, (_a = options.preventLoad) != null ? _a : false)
  );
  const saveAudioInputEnabled = React33.useCallback((isEnabled) => {
    setSettings((prev) => __spreadProps(__spreadValues({}, prev), { audioEnabled: isEnabled }));
  }, []);
  const saveVideoInputEnabled = React33.useCallback((isEnabled) => {
    setSettings((prev) => __spreadProps(__spreadValues({}, prev), { videoEnabled: isEnabled }));
  }, []);
  const saveAudioInputDeviceId = React33.useCallback((deviceId) => {
    setSettings((prev) => __spreadProps(__spreadValues({}, prev), { audioDeviceId: deviceId }));
  }, []);
  const saveVideoInputDeviceId = React33.useCallback((deviceId) => {
    setSettings((prev) => __spreadProps(__spreadValues({}, prev), { videoDeviceId: deviceId }));
  }, []);
  const saveUsername = React33.useCallback((username) => {
    setSettings((prev) => __spreadProps(__spreadValues({}, prev), { username }));
  }, []);
  React33.useEffect(() => {
    var _a2;
    saveUserChoices(userChoices, (_a2 = options.preventSave) != null ? _a2 : false);
  }, [userChoices, options.preventSave]);
  return {
    userChoices,
    saveAudioInputEnabled,
    saveVideoInputEnabled,
    saveAudioInputDeviceId,
    saveVideoInputDeviceId,
    saveUsername
  };
}

// src/hooks/useIsEncrypted.ts
import * as React34 from "react";
import { LocalParticipant } from "livekit-client";
import { encryptionStatusObservable } from "@livekit/components-core";
function useIsEncrypted(participant, options = {}) {
  const p = useEnsureParticipant(participant);
  const room = useEnsureRoom(options.room);
  const observer = React34.useMemo(() => encryptionStatusObservable(room, p), [room, p]);
  const isEncrypted = useObservableState(
    observer,
    p instanceof LocalParticipant ? p.isE2EEEnabled : p.isEncrypted
  );
  return isEncrypted;
}

// src/hooks/useTrackVolume.ts
import * as React35 from "react";
import { Track as Track3, createAudioAnalyser } from "livekit-client";
import {
  isTrackReference
} from "@livekit/components-core";
var normalizeFrequencies = (frequencies) => {
  const normalizeDb = (value) => {
    const minDb = -100;
    const maxDb = -10;
    let db = 1 - Math.max(minDb, Math.min(maxDb, value)) * -1 / 100;
    db = Math.sqrt(db);
    return db;
  };
  return frequencies.map((value) => {
    if (value === -Infinity) {
      return 0;
    }
    return normalizeDb(value);
  });
};
var multibandDefaults = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 10,
  analyserOptions: { fftSize: 2048 }
};
function useMultibandTrackVolume(trackOrTrackReference, options = {}) {
  var _a;
  const track = trackOrTrackReference instanceof Track3 ? trackOrTrackReference : (_a = trackOrTrackReference == null ? void 0 : trackOrTrackReference.publication) == null ? void 0 : _a.track;
  const [frequencyBands, setFrequencyBands] = React35.useState([]);
  const opts = __spreadValues(__spreadValues({}, multibandDefaults), options);
  React35.useEffect(() => {
    if (!track || !(track == null ? void 0 : track.mediaStream)) {
      return;
    }
    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);
    const updateVolume = () => {
      analyser.getFloatFrequencyData(dataArray);
      let frequencies = new Float32Array(dataArray.length);
      for (let i = 0; i < dataArray.length; i++) {
        frequencies[i] = dataArray[i];
      }
      frequencies = frequencies.slice(options.loPass, options.hiPass);
      const normalizedFrequencies = normalizeFrequencies(frequencies);
      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands);
      const chunks = [];
      for (let i = 0; i < opts.bands; i++) {
        const summedVolumes = normalizedFrequencies.slice(i * chunkSize, (i + 1) * chunkSize).reduce((acc, val) => acc += val, 0);
        chunks.push(summedVolumes / chunkSize);
      }
      setFrequencyBands(chunks);
    };
    const interval = setInterval(updateVolume, opts.updateInterval);
    return () => {
      cleanup();
      clearInterval(interval);
    };
  }, [track, track == null ? void 0 : track.mediaStream, JSON.stringify(options)]);
  return frequencyBands;
}

// src/components/controls/ChatToggle.tsx
import * as React36 from "react";
var ChatToggle = /* @__PURE__ */ React36.forwardRef(
  function ChatToggle2(props, ref) {
    const { mergedProps } = useChatToggle({ props });
    return /* @__PURE__ */ React36.createElement("button", __spreadValues({ ref }, mergedProps), props.children);
  }
);

// src/components/controls/DisconnectButton.tsx
import * as React37 from "react";
var DisconnectButton = /* @__PURE__ */ React37.forwardRef(
  function DisconnectButton2(props, ref) {
    const { buttonProps } = useDisconnectButton(props);
    return /* @__PURE__ */ React37.createElement("button", __spreadValues({ ref }, buttonProps), props.children);
  }
);

// src/components/controls/FocusToggle.tsx
import * as React57 from "react";

// src/assets/icons/CameraDisabledIcon.tsx
import * as React38 from "react";
var SvgCameraDisabledIcon = (props) => /* @__PURE__ */ React38.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor" }, props), /* @__PURE__ */ React38.createElement("path", { d: "M1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708L11 10.293V4.5A1.5 1.5 0 0 0 9.5 3H3.707zM0 4.5a1.5 1.5 0 0 1 .943-1.393l9.532 9.533c-.262.224-.603.36-.975.36h-8A1.5 1.5 0 0 1 0 11.5z" }), /* @__PURE__ */ React38.createElement("path", { d: "m15.2 3.6-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z" }));
var CameraDisabledIcon_default = SvgCameraDisabledIcon;

// src/assets/icons/CameraIcon.tsx
import * as React39 from "react";
var SvgCameraIcon = (props) => /* @__PURE__ */ React39.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor" }, props), /* @__PURE__ */ React39.createElement("path", { d: "M0 4.5A1.5 1.5 0 0 1 1.5 3h8A1.5 1.5 0 0 1 11 4.5v7A1.5 1.5 0 0 1 9.5 13h-8A1.5 1.5 0 0 1 0 11.5zM15.2 3.6l-2.8 2.1a1 1 0 0 0-.4.8v3a1 1 0 0 0 .4.8l2.8 2.1a.5.5 0 0 0 .8-.4V4a.5.5 0 0 0-.8-.4z" }));
var CameraIcon_default = SvgCameraIcon;

// src/assets/icons/ChatCloseIcon.tsx
import * as React40 from "react";
var SvgChatCloseIcon = (props) => /* @__PURE__ */ React40.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, viewBox: "0 0 24 24" }, props), /* @__PURE__ */ React40.createElement(
  "path",
  {
    fill: "#FFF",
    d: "M4.99 3.99a1 1 0 0 0-.697 1.717L10.586 12l-6.293 6.293a1 1 0 1 0 1.414 1.414L12 13.414l6.293 6.293a1 1 0 1 0 1.414-1.414L13.414 12l6.293-6.293a1 1 0 0 0-.727-1.717 1 1 0 0 0-.687.303L12 10.586 5.707 4.293a1 1 0 0 0-.717-.303z"
  }
));
var ChatCloseIcon_default = SvgChatCloseIcon;

// src/assets/icons/ChatIcon.tsx
import * as React41 from "react";
var SvgChatIcon = (props) => /* @__PURE__ */ React41.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 18, fill: "none" }, props), /* @__PURE__ */ React41.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M0 2.75A2.75 2.75 0 0 1 2.75 0h10.5A2.75 2.75 0 0 1 16 2.75v13.594a.75.75 0 0 1-1.234.572l-3.691-3.12a1.25 1.25 0 0 0-.807-.296H2.75A2.75 2.75 0 0 1 0 10.75v-8ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v8c0 .69.56 1.25 1.25 1.25h7.518c.65 0 1.279.23 1.775.65l2.457 2.077V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React41.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5Zm0 2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5Z",
    clipRule: "evenodd"
  }
));
var ChatIcon_default = SvgChatIcon;

// src/assets/icons/Chevron.tsx
import * as React42 from "react";
var SvgChevron = (props) => /* @__PURE__ */ React42.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React42.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M5.293 2.293a1 1 0 0 1 1.414 0l4.823 4.823a1.25 1.25 0 0 1 0 1.768l-4.823 4.823a1 1 0 0 1-1.414-1.414L9.586 8 5.293 3.707a1 1 0 0 1 0-1.414z",
    clipRule: "evenodd"
  }
));
var Chevron_default = SvgChevron;

// src/assets/icons/FocusToggleIcon.tsx
import * as React43 from "react";
var SvgFocusToggleIcon = (props) => /* @__PURE__ */ React43.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React43.createElement("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5 }, /* @__PURE__ */ React43.createElement("path", { d: "M10 1.75h4.25m0 0V6m0-4.25L9 7M6 14.25H1.75m0 0V10m0 4.25L7 9" })));
var FocusToggleIcon_default = SvgFocusToggleIcon;

// src/assets/icons/GearIcon.tsx
import * as React44 from "react";
var SvgGearIcon = (props) => /* @__PURE__ */ React44.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React44.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M8.961.894C8.875-.298 7.125-.298 7.04.894c-.066.912-1.246 1.228-1.76.472-.67-.99-2.186-.115-1.664.96.399.824-.465 1.688-1.288 1.289-1.076-.522-1.95.994-.961 1.665.756.513.44 1.693-.472 1.759-1.192.086-1.192 1.836 0 1.922.912.066 1.228 1.246.472 1.76-.99.67-.115 2.186.96 1.664.824-.399 1.688.465 1.289 1.288-.522 1.076.994 1.95 1.665.961.513-.756 1.693-.44 1.759.472.086 1.192 1.836 1.192 1.922 0 .066-.912 1.246-1.228 1.76-.472.67.99 2.186.115 1.664-.96-.399-.824.465-1.688 1.288-1.289 1.076.522 1.95-.994.961-1.665-.756-.513-.44-1.693.472-1.759 1.192-.086 1.192-1.836 0-1.922-.912-.066-1.228-1.246-.472-1.76.99-.67.115-2.186-.96-1.664-.824.399-1.688-.465-1.289-1.288.522-1.076-.994-1.95-1.665-.961-.513.756-1.693.44-1.759-.472ZM8 13A5 5 0 1 0 8 3a5 5 0 0 0 0 10Z",
    clipRule: "evenodd"
  }
));
var GearIcon_default = SvgGearIcon;

// src/assets/icons/LeaveIcon.tsx
import * as React45 from "react";
var SvgLeaveIcon = (props) => /* @__PURE__ */ React45.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React45.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M2 2.75A2.75 2.75 0 0 1 4.75 0h6.5A2.75 2.75 0 0 1 14 2.75v10.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-.5a.75.75 0 0 1 1.5 0v.5c0 .69.56 1.25 1.25 1.25h6.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25h-6.5c-.69 0-1.25.56-1.25 1.25v.5a.75.75 0 0 1-1.5 0v-.5Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React45.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8.78 7.47a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 1 1-1.06-1.06l.97-.97H1.75a.75.75 0 0 1 0-1.5h4.69l-.97-.97a.75.75 0 0 1 1.06-1.06l2.25 2.25Z",
    clipRule: "evenodd"
  }
));
var LeaveIcon_default = SvgLeaveIcon;

// src/assets/icons/LockLockedIcon.tsx
import * as React46 from "react";
var SvgLockLockedIcon = (props) => /* @__PURE__ */ React46.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React46.createElement(
  "path",
  {
    fill: "currentcolor",
    fillRule: "evenodd",
    d: "M4 6.104V4a4 4 0 1 1 8 0v2.104c1.154.326 2 1.387 2 2.646v4.5A2.75 2.75 0 0 1 11.25 16h-6.5A2.75 2.75 0 0 1 2 13.25v-4.5c0-1.259.846-2.32 2-2.646ZM5.5 4a2.5 2.5 0 0 1 5 0v2h-5V4Z",
    clipRule: "evenodd"
  }
));
var LockLockedIcon_default = SvgLockLockedIcon;

// src/assets/icons/MicDisabledIcon.tsx
import * as React47 from "react";
var SvgMicDisabledIcon = (props) => /* @__PURE__ */ React47.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor" }, props), /* @__PURE__ */ React47.createElement("path", { d: "M12.227 11.52a5.477 5.477 0 0 0 1.246-2.97.5.5 0 0 0-.995-.1 4.478 4.478 0 0 1-.962 2.359l-1.07-1.07C10.794 9.247 11 8.647 11 8V3a3 3 0 0 0-6 0v1.293L1.354.646a.5.5 0 1 0-.708.708l14 14a.5.5 0 0 0 .708-.708zM8 12.5c.683 0 1.33-.152 1.911-.425l.743.743c-.649.359-1.378.59-2.154.66V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .995-.098A4.5 4.5 0 0 0 8 12.5z" }), /* @__PURE__ */ React47.createElement("path", { d: "M8.743 10.907 5 7.164V8a3 3 0 0 0 3.743 2.907z" }));
var MicDisabledIcon_default = SvgMicDisabledIcon;

// src/assets/icons/MicIcon.tsx
import * as React48 from "react";
var SvgMicIcon = (props) => /* @__PURE__ */ React48.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor" }, props), /* @__PURE__ */ React48.createElement(
  "path",
  {
    fillRule: "evenodd",
    d: "M2.975 8.002a.5.5 0 0 1 .547.449 4.5 4.5 0 0 0 8.956 0 .5.5 0 1 1 .995.098A5.502 5.502 0 0 1 8.5 13.478V15h2a.5.5 0 0 1 0 1h-5a.5.5 0 0 1 0-1h2v-1.522a5.502 5.502 0 0 1-4.973-4.929.5.5 0 0 1 .448-.547z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React48.createElement("path", { d: "M5 3a3 3 0 1 1 6 0v5a3 3 0 0 1-6 0z" }));
var MicIcon_default = SvgMicIcon;

// src/assets/icons/QualityExcellentIcon.tsx
import * as React49 from "react";
var SvgQualityExcellentIcon = (props) => /* @__PURE__ */ React49.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor" }, props), /* @__PURE__ */ React49.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React49.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }));
var QualityExcellentIcon_default = SvgQualityExcellentIcon;

// src/assets/icons/QualityGoodIcon.tsx
import * as React50 from "react";
var SvgQualityGoodIcon = (props) => /* @__PURE__ */ React50.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor" }, props), /* @__PURE__ */ React50.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React50.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React50.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ React50.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React50.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" })));
var QualityGoodIcon_default = SvgQualityGoodIcon;

// src/assets/icons/QualityPoorIcon.tsx
import * as React51 from "react";
var SvgQualityPoorIcon = (props) => /* @__PURE__ */ React51.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentcolor" }, props), /* @__PURE__ */ React51.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React51.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React51.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ React51.createElement("path", { d: "M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React51.createElement("path", { d: "M6 6.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" }), /* @__PURE__ */ React51.createElement("path", { d: "M12 .5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5z" })));
var QualityPoorIcon_default = SvgQualityPoorIcon;

// src/assets/icons/QualityUnknownIcon.tsx
import * as React52 from "react";
var SvgQualityUnknownIcon = (props) => /* @__PURE__ */ React52.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "currentColor" }, props), /* @__PURE__ */ React52.createElement("g", { opacity: 0.25 }, /* @__PURE__ */ React52.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z" }), /* @__PURE__ */ React52.createElement("path", { d: "M0 11.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-4Zm6-5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-9Zm6-6a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v15a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5V.5Z" })));
var QualityUnknownIcon_default = SvgQualityUnknownIcon;

// src/assets/icons/ScreenShareIcon.tsx
import * as React53 from "react";
var SvgScreenShareIcon = (props) => /* @__PURE__ */ React53.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 20, height: 16, fill: "none" }, props), /* @__PURE__ */ React53.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M0 2.75A2.75 2.75 0 0 1 2.75 0h14.5A2.75 2.75 0 0 1 20 2.75v10.5A2.75 2.75 0 0 1 17.25 16H2.75A2.75 2.75 0 0 1 0 13.25V2.75ZM2.75 1.5c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h14.5c.69 0 1.25-.56 1.25-1.25V2.75c0-.69-.56-1.25-1.25-1.25H2.75Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React53.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M9.47 4.22a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1-1.06 1.06l-.97-.97v4.69a.75.75 0 0 1-1.5 0V6.56l-.97.97a.75.75 0 0 1-1.06-1.06l2.25-2.25Z",
    clipRule: "evenodd"
  }
));
var ScreenShareIcon_default = SvgScreenShareIcon;

// src/assets/icons/ScreenShareStopIcon.tsx
import * as React54 from "react";
var SvgScreenShareStopIcon = (props) => /* @__PURE__ */ React54.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 20, height: 16, fill: "none" }, props), /* @__PURE__ */ React54.createElement("g", { fill: "currentColor" }, /* @__PURE__ */ React54.createElement("path", { d: "M7.28 4.22a.75.75 0 0 0-1.06 1.06L8.94 8l-2.72 2.72a.75.75 0 1 0 1.06 1.06L10 9.06l2.72 2.72a.75.75 0 1 0 1.06-1.06L11.06 8l2.72-2.72a.75.75 0 0 0-1.06-1.06L10 6.94z" }), /* @__PURE__ */ React54.createElement(
  "path",
  {
    fillRule: "evenodd",
    d: "M2.75 0A2.75 2.75 0 0 0 0 2.75v10.5A2.75 2.75 0 0 0 2.75 16h14.5A2.75 2.75 0 0 0 20 13.25V2.75A2.75 2.75 0 0 0 17.25 0zM1.5 2.75c0-.69.56-1.25 1.25-1.25h14.5c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H2.75c-.69 0-1.25-.56-1.25-1.25z",
    clipRule: "evenodd"
  }
)));
var ScreenShareStopIcon_default = SvgScreenShareStopIcon;

// src/assets/icons/SpinnerIcon.tsx
import * as React55 from "react";
var SvgSpinnerIcon = (props) => /* @__PURE__ */ React55.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 8 0Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M8 12a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 8 12Z",
    clipRule: "evenodd",
    opacity: 0.7
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M12 1.072a.75.75 0 0 1 .274 1.024l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 12 1.072Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M6 11.464a.75.75 0 0 1 .274 1.025l-1.25 2.165a.75.75 0 0 1-1.299-.75l1.25-2.165A.75.75 0 0 1 6 11.464Z",
    clipRule: "evenodd",
    opacity: 0.6
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M14.928 4a.75.75 0 0 1-.274 1.025l-2.165 1.25a.75.75 0 1 1-.75-1.3l2.165-1.25A.75.75 0 0 1 14.928 4Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4.536 10a.75.75 0 0 1-.275 1.024l-2.165 1.25a.75.75 0 0 1-.75-1.298l2.165-1.25A.75.75 0 0 1 4.536 10Z",
    clipRule: "evenodd",
    opacity: 0.5
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M16 8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 16 8Z",
    clipRule: "evenodd"
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4 8a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 8Z",
    clipRule: "evenodd",
    opacity: 0.4
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M14.928 12a.75.75 0 0 1-1.024.274l-2.165-1.25a.75.75 0 0 1 .75-1.299l2.165 1.25A.75.75 0 0 1 14.928 12Z",
    clipRule: "evenodd",
    opacity: 0.9
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M4.536 6a.75.75 0 0 1-1.025.275l-2.165-1.25a.75.75 0 1 1 .75-1.3l2.165 1.25A.75.75 0 0 1 4.536 6Z",
    clipRule: "evenodd",
    opacity: 0.3
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M12 14.928a.75.75 0 0 1-1.024-.274l-1.25-2.165a.75.75 0 0 1 1.298-.75l1.25 2.165A.75.75 0 0 1 12 14.928Z",
    clipRule: "evenodd",
    opacity: 0.8
  }
), /* @__PURE__ */ React55.createElement(
  "path",
  {
    fill: "currentColor",
    fillRule: "evenodd",
    d: "M6 4.536a.75.75 0 0 1-1.024-.275l-1.25-2.165a.75.75 0 1 1 1.299-.75l1.25 2.165A.75.75 0 0 1 6 4.536Z",
    clipRule: "evenodd",
    opacity: 0.2
  }
));
var SpinnerIcon_default = SvgSpinnerIcon;

// src/assets/icons/UnfocusToggleIcon.tsx
import * as React56 from "react";
var SvgUnfocusToggleIcon = (props) => /* @__PURE__ */ React56.createElement("svg", __spreadValues({ xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none" }, props), /* @__PURE__ */ React56.createElement("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 1.5 }, /* @__PURE__ */ React56.createElement("path", { d: "M13.25 7H9m0 0V2.75M9 7l5.25-5.25M2.75 9H7m0 0v4.25M7 9l-5.25 5.25" })));
var UnfocusToggleIcon_default = SvgUnfocusToggleIcon;

// src/components/controls/FocusToggle.tsx
var FocusToggle = /* @__PURE__ */ React57.forwardRef(
  function FocusToggle2(_a, ref) {
    var _b = _a, { trackRef } = _b, props = __objRest(_b, ["trackRef"]);
    const trackRefFromContext = useMaybeTrackRefContext();
    const { mergedProps, inFocus } = useFocusToggle({
      trackRef: trackRef != null ? trackRef : trackRefFromContext,
      props
    });
    return /* @__PURE__ */ React57.createElement(LayoutContext.Consumer, null, (layoutContext) => layoutContext !== void 0 && /* @__PURE__ */ React57.createElement("button", __spreadValues({ ref }, mergedProps), props.children ? props.children : inFocus ? /* @__PURE__ */ React57.createElement(UnfocusToggleIcon_default, null) : /* @__PURE__ */ React57.createElement(FocusToggleIcon_default, null)));
  }
);

// src/components/controls/MediaDeviceSelect.tsx
import * as React58 from "react";
import { RoomEvent } from "livekit-client";
var MediaDeviceSelect = /* @__PURE__ */ React58.forwardRef(
  function MediaDeviceSelect2(_a, ref) {
    var _b = _a, {
      kind,
      initialSelection,
      onActiveDeviceChange,
      onDeviceListChange,
      onDeviceSelectError,
      exactMatch,
      track,
      requestPermissions,
      onError
    } = _b, props = __objRest(_b, [
      "kind",
      "initialSelection",
      "onActiveDeviceChange",
      "onDeviceListChange",
      "onDeviceSelectError",
      "exactMatch",
      "track",
      "requestPermissions",
      "onError"
    ]);
    const room = useMaybeRoomContext();
    const handleError = React58.useCallback(
      (e) => {
        if (room) {
          room.emit(RoomEvent.MediaDevicesError, e);
        }
        onError == null ? void 0 : onError(e);
      },
      [room, onError]
    );
    const { devices, activeDeviceId, setActiveMediaDevice, className } = useMediaDeviceSelect({
      kind,
      room,
      track,
      requestPermissions,
      onError: handleError
    });
    React58.useEffect(() => {
      if (initialSelection !== void 0) {
        setActiveMediaDevice(initialSelection);
      }
    }, [setActiveMediaDevice]);
    React58.useEffect(() => {
      if (typeof onDeviceListChange === "function") {
        onDeviceListChange(devices);
      }
    }, [onDeviceListChange, devices]);
    React58.useEffect(() => {
      if (activeDeviceId && activeDeviceId !== "") {
        onActiveDeviceChange == null ? void 0 : onActiveDeviceChange(activeDeviceId);
      }
    }, [activeDeviceId]);
    const handleActiveDeviceChange = (deviceId) => __async(this, null, function* () {
      try {
        yield setActiveMediaDevice(deviceId, { exact: exactMatch });
      } catch (e) {
        if (e instanceof Error) {
          onDeviceSelectError == null ? void 0 : onDeviceSelectError(e);
        } else {
          throw e;
        }
      }
    });
    const mergedProps = React58.useMemo(
      () => mergeProps2(props, { className }, { className: "lk-list" }),
      [className, props]
    );
    function isActive(deviceId, activeDeviceId2, index) {
      return deviceId === activeDeviceId2 || index === 0 && activeDeviceId2 === "default";
    }
    return /* @__PURE__ */ React58.createElement("ul", __spreadValues({ ref }, mergedProps), devices.map((device, index) => /* @__PURE__ */ React58.createElement(
      "li",
      {
        key: device.deviceId,
        id: device.deviceId,
        "data-lk-active": isActive(device.deviceId, activeDeviceId, index),
        "aria-selected": isActive(device.deviceId, activeDeviceId, index),
        role: "option"
      },
      /* @__PURE__ */ React58.createElement("button", { className: "lk-button", onClick: () => handleActiveDeviceChange(device.deviceId) }, device.label)
    )));
  }
);

// src/components/controls/TrackToggle.tsx
import * as React60 from "react";

// src/assets/icons/util.tsx
import * as React59 from "react";
import { ConnectionQuality as ConnectionQuality2, Track as Track4 } from "livekit-client";
function getSourceIcon(source, enabled) {
  switch (source) {
    case Track4.Source.Microphone:
      return enabled ? /* @__PURE__ */ React59.createElement(MicIcon_default, null) : /* @__PURE__ */ React59.createElement(MicDisabledIcon_default, null);
    case Track4.Source.Camera:
      return enabled ? /* @__PURE__ */ React59.createElement(CameraIcon_default, null) : /* @__PURE__ */ React59.createElement(CameraDisabledIcon_default, null);
    case Track4.Source.ScreenShare:
      return enabled ? /* @__PURE__ */ React59.createElement(ScreenShareStopIcon_default, null) : /* @__PURE__ */ React59.createElement(ScreenShareIcon_default, null);
    default:
      return void 0;
  }
}
function getConnectionQualityIcon(quality) {
  switch (quality) {
    case ConnectionQuality2.Excellent:
      return /* @__PURE__ */ React59.createElement(QualityExcellentIcon_default, null);
    case ConnectionQuality2.Good:
      return /* @__PURE__ */ React59.createElement(QualityGoodIcon_default, null);
    case ConnectionQuality2.Poor:
      return /* @__PURE__ */ React59.createElement(QualityPoorIcon_default, null);
    default:
      return /* @__PURE__ */ React59.createElement(QualityUnknownIcon_default, null);
  }
}

// src/components/controls/TrackToggle.tsx
var TrackToggle = /* @__PURE__ */ React60.forwardRef(function TrackToggle2(_a, ref) {
  var _b = _a, { showIcon } = _b, props = __objRest(_b, ["showIcon"]);
  const { buttonProps, enabled } = useTrackToggle(props);
  return /* @__PURE__ */ React60.createElement("button", __spreadValues({ ref }, buttonProps), (showIcon != null ? showIcon : true) && getSourceIcon(props.source, enabled), props.children);
});

// src/components/layout/FocusLayout.tsx
import * as React69 from "react";

// src/components/participant/ParticipantTile.tsx
import * as React68 from "react";
import { Track as Track5 } from "livekit-client";
import { isTrackReference as isTrackReference3, isTrackReferencePinned as isTrackReferencePinned2 } from "@livekit/components-core";

// src/components/participant/ConnectionQualityIndicator.tsx
import * as React61 from "react";
var ConnectionQualityIndicator = /* @__PURE__ */ React61.forwardRef(function ConnectionQualityIndicator2(props, ref) {
  var _a;
  const { className, quality } = useConnectionQualityIndicator(props);
  const elementProps = React61.useMemo(() => {
    return __spreadProps(__spreadValues({}, mergeProps2(props, { className })), { "data-lk-quality": quality });
  }, [quality, props, className]);
  return /* @__PURE__ */ React61.createElement("div", __spreadValues({ ref }, elementProps), (_a = props.children) != null ? _a : getConnectionQualityIcon(quality));
});

// src/components/participant/ParticipantName.tsx
import { setupParticipantName } from "@livekit/components-core";
import * as React62 from "react";
var ParticipantName = /* @__PURE__ */ React62.forwardRef(
  function ParticipantName2(_a, ref) {
    var _b = _a, { participant } = _b, props = __objRest(_b, ["participant"]);
    const p = useEnsureParticipant(participant);
    const { className, infoObserver } = React62.useMemo(() => {
      return setupParticipantName(p);
    }, [p]);
    const { identity, name } = useObservableState(infoObserver, {
      name: p.name,
      identity: p.identity,
      metadata: p.metadata
    });
    const mergedProps = React62.useMemo(() => {
      return mergeProps2(props, { className, "data-lk-participant-name": name });
    }, [props, className, name]);
    return /* @__PURE__ */ React62.createElement("span", __spreadValues({ ref }, mergedProps), name !== "" ? name : identity, props.children);
  }
);

// src/components/participant/TrackMutedIndicator.tsx
import * as React63 from "react";
var TrackMutedIndicator = /* @__PURE__ */ React63.forwardRef(
  function TrackMutedIndicator2(_a, ref) {
    var _b = _a, { trackRef, show = "always" } = _b, props = __objRest(_b, ["trackRef", "show"]);
    var _a2;
    const { className, isMuted } = useTrackMutedIndicator(trackRef);
    const showIndicator = show === "always" || show === "muted" && isMuted || show === "unmuted" && !isMuted;
    const htmlProps = React63.useMemo(
      () => mergeProps2(props, {
        className
      }),
      [className, props]
    );
    if (!showIndicator) {
      return null;
    }
    return /* @__PURE__ */ React63.createElement("div", __spreadProps(__spreadValues({ ref }, htmlProps), { "data-lk-muted": isMuted }), (_a2 = props.children) != null ? _a2 : getSourceIcon(trackRef.source, !isMuted));
  }
);

// src/assets/images/ParticipantPlaceholder.tsx
import * as React64 from "react";
var SvgParticipantPlaceholder = (props) => /* @__PURE__ */ React64.createElement(
  "svg",
  __spreadValues({
    width: 320,
    height: 320,
    viewBox: "0 0 320 320",
    preserveAspectRatio: "xMidYMid meet",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props),
  /* @__PURE__ */ React64.createElement(
    "path",
    {
      d: "M160 180C204.182 180 240 144.183 240 100C240 55.8172 204.182 20 160 20C115.817 20 79.9997 55.8172 79.9997 100C79.9997 144.183 115.817 180 160 180Z",
      fill: "white",
      fillOpacity: 0.25
    }
  ),
  /* @__PURE__ */ React64.createElement(
    "path",
    {
      d: "M97.6542 194.614C103.267 191.818 109.841 192.481 115.519 195.141C129.025 201.466 144.1 205 159.999 205C175.899 205 190.973 201.466 204.48 195.141C210.158 192.481 216.732 191.818 222.345 194.614C262.703 214.719 291.985 253.736 298.591 300.062C300.15 310.997 291.045 320 280 320H39.9997C28.954 320 19.8495 310.997 21.4087 300.062C28.014 253.736 57.2966 214.72 97.6542 194.614Z",
      fill: "white",
      fillOpacity: 0.25
    }
  )
);
var ParticipantPlaceholder_default = SvgParticipantPlaceholder;

// src/components/participant/VideoTrack.tsx
import { RemoteTrackPublication } from "livekit-client";
import * as React66 from "react";

// src/hooks/useMediaTrackBySourceOrName.ts
import { isTrackReference as isTrackReference2 } from "@livekit/components-core";
import { setupMediaTrack, log as log6, isLocal, getTrackByIdentifier } from "@livekit/components-core";
import * as React65 from "react";
function useMediaTrackBySourceOrName(observerOptions, options = {}) {
  var _a;
  const [publication, setPublication] = React65.useState(getTrackByIdentifier(observerOptions));
  const [isMuted, setMuted] = React65.useState(publication == null ? void 0 : publication.isMuted);
  const [isSubscribed, setSubscribed] = React65.useState(publication == null ? void 0 : publication.isSubscribed);
  const [track, setTrack] = React65.useState(publication == null ? void 0 : publication.track);
  const [orientation, setOrientation] = React65.useState("landscape");
  const previousElement = React65.useRef();
  const { className, trackObserver } = React65.useMemo(() => {
    return setupMediaTrack(observerOptions);
  }, [
    (_a = observerOptions.participant.sid) != null ? _a : observerOptions.participant.identity,
    observerOptions.source,
    isTrackReference2(observerOptions) && observerOptions.publication.trackSid
  ]);
  React65.useEffect(() => {
    const subscription = trackObserver.subscribe((publication2) => {
      log6.debug("update track", publication2);
      setPublication(publication2);
      setMuted(publication2 == null ? void 0 : publication2.isMuted);
      setSubscribed(publication2 == null ? void 0 : publication2.isSubscribed);
      setTrack(publication2 == null ? void 0 : publication2.track);
    });
    return () => subscription == null ? void 0 : subscription.unsubscribe();
  }, [trackObserver]);
  React65.useEffect(() => {
    var _a2, _b;
    if (track) {
      if (previousElement.current) {
        track.detach(previousElement.current);
      }
      if (((_a2 = options.element) == null ? void 0 : _a2.current) && !(isLocal(observerOptions.participant) && (track == null ? void 0 : track.kind) === "audio")) {
        track.attach(options.element.current);
      }
    }
    previousElement.current = (_b = options.element) == null ? void 0 : _b.current;
    return () => {
      if (previousElement.current) {
        track == null ? void 0 : track.detach(previousElement.current);
      }
    };
  }, [track, options.element]);
  React65.useEffect(() => {
    var _a2, _b;
    if (typeof ((_a2 = publication == null ? void 0 : publication.dimensions) == null ? void 0 : _a2.width) === "number" && typeof ((_b = publication == null ? void 0 : publication.dimensions) == null ? void 0 : _b.height) === "number") {
      const orientation_ = publication.dimensions.width > publication.dimensions.height ? "landscape" : "portrait";
      setOrientation(orientation_);
    }
  }, [publication]);
  return {
    publication,
    isMuted,
    isSubscribed,
    track,
    elementProps: mergeProps2(options.props, __spreadValues({
      className,
      "data-lk-local-participant": observerOptions.participant.isLocal,
      "data-lk-source": publication == null ? void 0 : publication.source
    }, (publication == null ? void 0 : publication.kind) === "video" && { "data-lk-orientation": orientation }))
  };
}

// src/components/participant/VideoTrack.tsx
import * as useHooks from "usehooks-ts";
var VideoTrack = /* @__PURE__ */ React66.forwardRef(
  function VideoTrack2(_a, ref) {
    var _b = _a, {
      onTrackClick,
      onClick,
      onSubscriptionStatusChanged,
      trackRef,
      manageSubscription
    } = _b, props = __objRest(_b, [
      "onTrackClick",
      "onClick",
      "onSubscriptionStatusChanged",
      "trackRef",
      "manageSubscription"
    ]);
    const trackReference = useEnsureTrackRef(trackRef);
    const mediaEl = React66.useRef(null);
    React66.useImperativeHandle(ref, () => mediaEl.current);
    const intersectionEntry = useHooks.useIntersectionObserver({ root: mediaEl.current });
    const [debouncedIntersectionEntry] = useHooks.useDebounceValue(intersectionEntry, 3e3);
    React66.useEffect(() => {
      if (manageSubscription && trackReference.publication instanceof RemoteTrackPublication && (debouncedIntersectionEntry == null ? void 0 : debouncedIntersectionEntry.isIntersecting) === false && (intersectionEntry == null ? void 0 : intersectionEntry.isIntersecting) === false) {
        trackReference.publication.setSubscribed(false);
      }
    }, [debouncedIntersectionEntry, trackReference, manageSubscription]);
    React66.useEffect(() => {
      if (manageSubscription && trackReference.publication instanceof RemoteTrackPublication && (intersectionEntry == null ? void 0 : intersectionEntry.isIntersecting) === true) {
        trackReference.publication.setSubscribed(true);
      }
    }, [intersectionEntry, trackReference, manageSubscription]);
    const {
      elementProps,
      publication: pub,
      isSubscribed
    } = useMediaTrackBySourceOrName(trackReference, {
      element: mediaEl,
      props
    });
    React66.useEffect(() => {
      onSubscriptionStatusChanged == null ? void 0 : onSubscriptionStatusChanged(!!isSubscribed);
    }, [isSubscribed, onSubscriptionStatusChanged]);
    const clickHandler = (evt) => {
      onClick == null ? void 0 : onClick(evt);
      onTrackClick == null ? void 0 : onTrackClick({ participant: trackReference == null ? void 0 : trackReference.participant, track: pub });
    };
    return /* @__PURE__ */ React66.createElement("video", __spreadProps(__spreadValues({ ref: mediaEl }, elementProps), { muted: true, onClick: clickHandler }));
  }
);

// src/components/participant/AudioTrack.tsx
import * as React67 from "react";
import { log as log7 } from "@livekit/components-core";
import { RemoteAudioTrack, RemoteTrackPublication as RemoteTrackPublication2 } from "livekit-client";
var AudioTrack = /* @__PURE__ */ React67.forwardRef(
  function AudioTrack2(_a, ref) {
    var _b = _a, { trackRef, onSubscriptionStatusChanged, volume, muted } = _b, props = __objRest(_b, ["trackRef", "onSubscriptionStatusChanged", "volume", "muted"]);
    const trackReference = useEnsureTrackRef(trackRef);
    const mediaEl = React67.useRef(null);
    React67.useImperativeHandle(ref, () => mediaEl.current);
    const {
      elementProps,
      isSubscribed,
      track,
      publication: pub
    } = useMediaTrackBySourceOrName(trackReference, {
      element: mediaEl,
      props
    });
    React67.useEffect(() => {
      onSubscriptionStatusChanged == null ? void 0 : onSubscriptionStatusChanged(!!isSubscribed);
    }, [isSubscribed, onSubscriptionStatusChanged]);
    React67.useEffect(() => {
      if (track === void 0 || volume === void 0) {
        return;
      }
      if (track instanceof RemoteAudioTrack) {
        track.setVolume(volume);
      } else {
        log7.warn("Volume can only be set on remote audio tracks.");
      }
    }, [volume, track]);
    React67.useEffect(() => {
      if (pub === void 0 || muted === void 0) {
        return;
      }
      if (pub instanceof RemoteTrackPublication2) {
        pub.setEnabled(!muted);
      } else {
        log7.warn("Can only call setEnabled on remote track publications.");
      }
    }, [muted, pub, track]);
    return /* @__PURE__ */ React67.createElement("audio", __spreadValues({ ref: mediaEl }, elementProps));
  }
);

// src/components/participant/ParticipantTile.tsx
function ParticipantContextIfNeeded(props) {
  const hasContext = !!useMaybeParticipantContext();
  return props.participant && !hasContext ? /* @__PURE__ */ React68.createElement(ParticipantContext.Provider, { value: props.participant }, props.children) : /* @__PURE__ */ React68.createElement(React68.Fragment, null, props.children);
}
function TrackRefContextIfNeeded(props) {
  const hasContext = !!useMaybeTrackRefContext();
  return props.trackRef && !hasContext ? /* @__PURE__ */ React68.createElement(TrackRefContext.Provider, { value: props.trackRef }, props.children) : /* @__PURE__ */ React68.createElement(React68.Fragment, null, props.children);
}
var ParticipantTile = /* @__PURE__ */ React68.forwardRef(
  function ParticipantTile2(_a, ref) {
    var _b = _a, {
      trackRef,
      children,
      onParticipantClick,
      disableSpeakingIndicator
    } = _b, htmlProps = __objRest(_b, [
      "trackRef",
      "children",
      "onParticipantClick",
      "disableSpeakingIndicator"
    ]);
    var _a2, _b2;
    const trackReference = useEnsureTrackRef(trackRef);
    const { elementProps } = useParticipantTile({
      htmlProps,
      disableSpeakingIndicator,
      onParticipantClick,
      trackRef: trackReference
    });
    const isEncrypted = useIsEncrypted(trackReference.participant);
    const layoutContext = useMaybeLayoutContext();
    const autoManageSubscription = (_a2 = useFeatureContext()) == null ? void 0 : _a2.autoSubscription;
    const handleSubscribe = React68.useCallback(
      (subscribed) => {
        if (trackReference.source && !subscribed && layoutContext && layoutContext.pin.dispatch && isTrackReferencePinned2(trackReference, layoutContext.pin.state)) {
          layoutContext.pin.dispatch({ msg: "clear_pin" });
        }
      },
      [trackReference, layoutContext]
    );
    return /* @__PURE__ */ React68.createElement("div", __spreadValues({ ref, style: { position: "relative" } }, elementProps), /* @__PURE__ */ React68.createElement(TrackRefContextIfNeeded, { trackRef: trackReference }, /* @__PURE__ */ React68.createElement(ParticipantContextIfNeeded, { participant: trackReference.participant }, children != null ? children : /* @__PURE__ */ React68.createElement(React68.Fragment, null, isTrackReference3(trackReference) && (((_b2 = trackReference.publication) == null ? void 0 : _b2.kind) === "video" || trackReference.source === Track5.Source.Camera || trackReference.source === Track5.Source.ScreenShare) ? /* @__PURE__ */ React68.createElement(
      VideoTrack,
      {
        trackRef: trackReference,
        onSubscriptionStatusChanged: handleSubscribe,
        manageSubscription: autoManageSubscription
      }
    ) : isTrackReference3(trackReference) && /* @__PURE__ */ React68.createElement(
      AudioTrack,
      {
        trackRef: trackReference,
        onSubscriptionStatusChanged: handleSubscribe
      }
    ), /* @__PURE__ */ React68.createElement("div", { className: "lk-participant-placeholder" }, /* @__PURE__ */ React68.createElement(ParticipantPlaceholder_default, null)), /* @__PURE__ */ React68.createElement("div", { className: "lk-participant-metadata" }, /* @__PURE__ */ React68.createElement("div", { className: "lk-participant-metadata-item" }, trackReference.source === Track5.Source.Camera ? /* @__PURE__ */ React68.createElement(React68.Fragment, null, isEncrypted && /* @__PURE__ */ React68.createElement(LockLockedIcon_default, { style: { marginRight: "0.25rem" } }), /* @__PURE__ */ React68.createElement(
      TrackMutedIndicator,
      {
        trackRef: {
          participant: trackReference.participant,
          source: Track5.Source.Microphone
        },
        show: "muted"
      }
    ), /* @__PURE__ */ React68.createElement(ParticipantName, null)) : /* @__PURE__ */ React68.createElement(React68.Fragment, null, /* @__PURE__ */ React68.createElement(ScreenShareIcon_default, { style: { marginRight: "0.25rem" } }), /* @__PURE__ */ React68.createElement(ParticipantName, null, "'s screen"))), /* @__PURE__ */ React68.createElement(ConnectionQualityIndicator, { className: "lk-participant-metadata-item" }))), /* @__PURE__ */ React68.createElement(FocusToggle, { trackRef: trackReference }))));
  }
);

// src/components/layout/FocusLayout.tsx
function FocusLayoutContainer(props) {
  const elementProps = mergeProps2(props, { className: "lk-focus-layout" });
  return /* @__PURE__ */ React69.createElement("div", __spreadValues({}, elementProps), props.children);
}
function FocusLayout(_a) {
  var _b = _a, { trackRef } = _b, htmlProps = __objRest(_b, ["trackRef"]);
  return /* @__PURE__ */ React69.createElement(ParticipantTile, __spreadValues({ trackRef }, htmlProps));
}

// src/components/layout/GridLayout.tsx
import * as React73 from "react";

// src/components/TrackLoop.tsx
import * as React70 from "react";
import { getTrackReferenceId as getTrackReferenceId3 } from "@livekit/components-core";
function TrackLoop(_a) {
  var _b = _a, { tracks } = _b, props = __objRest(_b, ["tracks"]);
  return /* @__PURE__ */ React70.createElement(React70.Fragment, null, tracks.map((trackReference) => {
    return /* @__PURE__ */ React70.createElement(
      TrackRefContext.Provider,
      {
        value: trackReference,
        key: getTrackReferenceId3(trackReference)
      },
      cloneSingleChild(props.children)
    );
  }));
}

// src/components/controls/PaginationControl.tsx
import * as React71 from "react";
import { createInteractingObservable } from "@livekit/components-core";
function PaginationControl({
  totalPageCount,
  nextPage,
  prevPage,
  currentPage,
  pagesContainer: connectedElement
}) {
  const [interactive, setInteractive] = React71.useState(false);
  React71.useEffect(() => {
    let subscription;
    if (connectedElement) {
      subscription = createInteractingObservable(connectedElement.current, 2e3).subscribe(
        setInteractive
      );
    }
    return () => {
      if (subscription) {
        subscription.unsubscribe();
      }
    };
  }, [connectedElement]);
  return /* @__PURE__ */ React71.createElement("div", { className: "lk-pagination-control", "data-lk-user-interaction": interactive }, /* @__PURE__ */ React71.createElement("button", { className: "lk-button", onClick: prevPage }, /* @__PURE__ */ React71.createElement(Chevron_default, null)), /* @__PURE__ */ React71.createElement("span", { className: "lk-pagination-count" }, `${currentPage} of ${totalPageCount}`), /* @__PURE__ */ React71.createElement("button", { className: "lk-button", onClick: nextPage }, /* @__PURE__ */ React71.createElement(Chevron_default, null)));
}

// src/components/controls/PaginationIndicator.tsx
import * as React72 from "react";
var PaginationIndicator = /* @__PURE__ */ React72.forwardRef(
  function PaginationIndicator2({ totalPageCount, currentPage }, ref) {
    const bubbles = new Array(totalPageCount).fill("").map((_, index) => {
      if (index + 1 === currentPage) {
        return /* @__PURE__ */ React72.createElement("span", { "data-lk-active": true, key: index });
      } else {
        return /* @__PURE__ */ React72.createElement("span", { key: index });
      }
    });
    return /* @__PURE__ */ React72.createElement("div", { ref, className: "lk-pagination-indicator" }, bubbles);
  }
);

// src/components/layout/GridLayout.tsx
function GridLayout(_a) {
  var _b = _a, { tracks } = _b, props = __objRest(_b, ["tracks"]);
  const gridEl = React73.createRef();
  const elementProps = React73.useMemo(
    () => mergeProps2(props, { className: "lk-grid-layout" }),
    [props]
  );
  const { layout } = useGridLayout(gridEl, tracks.length);
  const pagination = usePagination(layout.maxTiles, tracks);
  useSwipe(gridEl, {
    onLeftSwipe: pagination.nextPage,
    onRightSwipe: pagination.prevPage
  });
  return /* @__PURE__ */ React73.createElement("div", __spreadValues({ ref: gridEl, "data-lk-pagination": pagination.totalPageCount > 1 }, elementProps), /* @__PURE__ */ React73.createElement(TrackLoop, { tracks: pagination.tracks }, props.children), tracks.length > layout.maxTiles && /* @__PURE__ */ React73.createElement(React73.Fragment, null, /* @__PURE__ */ React73.createElement(
    PaginationIndicator,
    {
      totalPageCount: pagination.totalPageCount,
      currentPage: pagination.currentPage
    }
  ), /* @__PURE__ */ React73.createElement(PaginationControl, __spreadValues({ pagesContainer: gridEl }, pagination))));
}

// src/components/layout/CarouselLayout.tsx
import { getScrollBarWidth } from "@livekit/components-core";
import * as React74 from "react";
var MIN_HEIGHT = 130;
var MIN_WIDTH = 140;
var MIN_VISIBLE_TILES = 1;
var ASPECT_RATIO = 16 / 10;
var ASPECT_RATIO_INVERT = (1 - ASPECT_RATIO) * -1;
function CarouselLayout(_a) {
  var _b = _a, { tracks, orientation } = _b, props = __objRest(_b, ["tracks", "orientation"]);
  const asideEl = React74.useRef(null);
  const [prevTiles, setPrevTiles] = React74.useState(0);
  const { width, height } = useSize(asideEl);
  const carouselOrientation = orientation ? orientation : height >= width ? "vertical" : "horizontal";
  const tileSpan = carouselOrientation === "vertical" ? Math.max(width * ASPECT_RATIO_INVERT, MIN_HEIGHT) : Math.max(height * ASPECT_RATIO, MIN_WIDTH);
  const scrollBarWidth = getScrollBarWidth();
  const tilesThatFit = carouselOrientation === "vertical" ? Math.max((height - scrollBarWidth) / tileSpan, MIN_VISIBLE_TILES) : Math.max((width - scrollBarWidth) / tileSpan, MIN_VISIBLE_TILES);
  let maxVisibleTiles = Math.round(tilesThatFit);
  if (Math.abs(tilesThatFit - prevTiles) < 0.5) {
    maxVisibleTiles = Math.round(prevTiles);
  } else if (prevTiles !== tilesThatFit) {
    setPrevTiles(tilesThatFit);
  }
  const sortedTiles = useVisualStableUpdate(tracks, maxVisibleTiles);
  React74.useLayoutEffect(() => {
    if (asideEl.current) {
      asideEl.current.dataset.lkOrientation = carouselOrientation;
      asideEl.current.style.setProperty("--lk-max-visible-tiles", maxVisibleTiles.toString());
    }
  }, [maxVisibleTiles, carouselOrientation]);
  return /* @__PURE__ */ React74.createElement("aside", __spreadValues({ key: carouselOrientation, className: "lk-carousel", ref: asideEl }, props), /* @__PURE__ */ React74.createElement(TrackLoop, { tracks: sortedTiles }, props.children));
}

// src/components/layout/LayoutContextProvider.tsx
import { log as log8 } from "@livekit/components-core";
import * as React75 from "react";
function LayoutContextProvider({
  value,
  onPinChange,
  onWidgetChange,
  children
}) {
  const layoutContextValue = useEnsureCreateLayoutContext(value);
  React75.useEffect(() => {
    log8.debug("PinState Updated", { state: layoutContextValue.pin.state });
    if (onPinChange && layoutContextValue.pin.state) onPinChange(layoutContextValue.pin.state);
  }, [layoutContextValue.pin.state, onPinChange]);
  React75.useEffect(() => {
    log8.debug("Widget Updated", { widgetState: layoutContextValue.widget.state });
    if (onWidgetChange && layoutContextValue.widget.state) {
      onWidgetChange(layoutContextValue.widget.state);
    }
  }, [onWidgetChange, layoutContextValue.widget.state]);
  return /* @__PURE__ */ React75.createElement(LayoutContext.Provider, { value: layoutContextValue }, children);
}

// src/components/participant/AudioVisualizer.tsx
import * as React76 from "react";
var AudioVisualizer = /* @__PURE__ */ React76.forwardRef(
  function AudioVisualizer2(_a, ref) {
    var _b = _a, { trackRef } = _b, props = __objRest(_b, ["trackRef"]);
    const svgWidth = 200;
    const svgHeight = 90;
    const barWidth = 6;
    const barSpacing = 4;
    const volMultiplier = 50;
    const barCount = 7;
    const trackReference = useEnsureTrackRef(trackRef);
    const volumes = useMultibandTrackVolume(trackReference, { bands: 7, loPass: 300 });
    return /* @__PURE__ */ React76.createElement(
      "svg",
      __spreadProps(__spreadValues({
        ref,
        width: "100%",
        height: "100%",
        viewBox: `0 0 ${svgWidth} ${svgHeight}`
      }, props), {
        className: "lk-audio-visualizer"
      }),
      /* @__PURE__ */ React76.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%" }),
      /* @__PURE__ */ React76.createElement(
        "g",
        {
          style: {
            transform: `translate(${(svgWidth - barCount * (barWidth + barSpacing)) / 2}px, 0)`
          }
        },
        volumes.map((vol, idx) => /* @__PURE__ */ React76.createElement(
          "rect",
          {
            key: idx,
            x: idx * (barWidth + barSpacing),
            y: svgHeight / 2 - vol * volMultiplier / 2,
            width: barWidth,
            height: vol * volMultiplier
          }
        ))
      )
    );
  }
);

// src/components/RoomAudioRenderer.tsx
import { getTrackReferenceId as getTrackReferenceId4, isLocal as isLocal2 } from "@livekit/components-core";
import { Track as Track6 } from "livekit-client";
import * as React77 from "react";
function RoomAudioRenderer({ volume, muted }) {
  const tracks = useTracks(
    [Track6.Source.Microphone, Track6.Source.ScreenShareAudio, Track6.Source.Unknown],
    {
      updateOnlyOn: [],
      onlySubscribed: true
    }
  ).filter((ref) => !isLocal2(ref.participant) && ref.publication.kind === Track6.Kind.Audio);
  return /* @__PURE__ */ React77.createElement("div", { style: { display: "none" } }, tracks.map((trackRef) => /* @__PURE__ */ React77.createElement(
    AudioTrack,
    {
      key: getTrackReferenceId4(trackRef),
      trackRef,
      volume,
      muted
    }
  )));
}

// src/components/Toast.tsx
import * as React78 from "react";
function Toast(props) {
  const htmlProps = React78.useMemo(() => mergeProps2(props, { className: "lk-toast" }), [props]);
  return /* @__PURE__ */ React78.createElement("div", __spreadValues({}, htmlProps), props.children);
}

// src/components/participant/ParticipantAudioTile.tsx
import * as React79 from "react";
import { isTrackReference as isTrackReference4 } from "@livekit/components-core";
var ParticipantAudioTile = /* @__PURE__ */ React79.forwardRef(
  function ParticipantAudioTile2(_a, ref) {
    var _b = _a, {
      children,
      disableSpeakingIndicator,
      onParticipantClick,
      trackRef
    } = _b, htmlProps = __objRest(_b, [
      "children",
      "disableSpeakingIndicator",
      "onParticipantClick",
      "trackRef"
    ]);
    const trackReference = useEnsureTrackRef(trackRef);
    const { elementProps } = useParticipantTile({
      trackRef: trackReference,
      htmlProps,
      disableSpeakingIndicator,
      onParticipantClick
    });
    return /* @__PURE__ */ React79.createElement("div", __spreadValues({ ref, style: { position: "relative" } }, elementProps), /* @__PURE__ */ React79.createElement(TrackRefContext.Provider, { value: trackReference }, children != null ? children : /* @__PURE__ */ React79.createElement(React79.Fragment, null, isTrackReference4(trackReference) && /* @__PURE__ */ React79.createElement(AudioTrack, { trackRef: trackReference }), /* @__PURE__ */ React79.createElement(AudioVisualizer, null), /* @__PURE__ */ React79.createElement("div", { className: "lk-participant-metadata" }, /* @__PURE__ */ React79.createElement("div", { className: "lk-participant-metadata-item" }, /* @__PURE__ */ React79.createElement(TrackMutedIndicator, { trackRef: trackReference }), /* @__PURE__ */ React79.createElement(ParticipantName, null)), /* @__PURE__ */ React79.createElement(ConnectionQualityIndicator, { className: "lk-participant-metadata-item" })))));
  }
);

// src/components/ConnectionStateToast.tsx
import { ConnectionState as ConnectionState3 } from "livekit-client";
import * as React80 from "react";
function ConnectionStateToast(props) {
  const [notification, setNotification] = React80.useState(void 0);
  const state = useConnectionState(props.room);
  React80.useEffect(() => {
    switch (state) {
      case ConnectionState3.Reconnecting:
        setNotification(
          /* @__PURE__ */ React80.createElement(React80.Fragment, null, /* @__PURE__ */ React80.createElement(SpinnerIcon_default, { className: "lk-spinner" }), " Reconnecting")
        );
        break;
      case ConnectionState3.Connecting:
        setNotification(
          /* @__PURE__ */ React80.createElement(React80.Fragment, null, /* @__PURE__ */ React80.createElement(SpinnerIcon_default, { className: "lk-spinner" }), " Connecting")
        );
        break;
      case ConnectionState3.Disconnected:
        setNotification(/* @__PURE__ */ React80.createElement(React80.Fragment, null, "Disconnected"));
        break;
      default:
        setNotification(void 0);
        break;
    }
  }, [state]);
  return notification ? /* @__PURE__ */ React80.createElement(Toast, { className: "lk-toast-connection-state" }, notification) : /* @__PURE__ */ React80.createElement(React80.Fragment, null);
}

// src/prefabs/Chat.tsx
function Chat(_a) {
  var _b = _a, {
    messageFormatter,
    messageDecoder,
    messageEncoder,
    channelTopic
  } = _b, props = __objRest(_b, [
    "messageFormatter",
    "messageDecoder",
    "messageEncoder",
    "channelTopic"
  ]);
  const inputRef = React81.useRef(null);
  const ulRef = React81.useRef(null);
  const chatOptions = React81.useMemo(() => {
    return { messageDecoder, messageEncoder, channelTopic };
  }, [messageDecoder, messageEncoder, channelTopic]);
  const { send, chatMessages, isSending } = useChat(chatOptions);
  const layoutContext = useMaybeLayoutContext();
  const lastReadMsgAt = React81.useRef(0);
  function handleSubmit(event) {
    return __async(this, null, function* () {
      event.preventDefault();
      if (inputRef.current && inputRef.current.value.trim() !== "") {
        if (send) {
          yield send(inputRef.current.value);
          inputRef.current.value = "";
          inputRef.current.focus();
        }
      }
    });
  }
  React81.useEffect(() => {
    var _a2;
    if (ulRef) {
      (_a2 = ulRef.current) == null ? void 0 : _a2.scrollTo({ top: ulRef.current.scrollHeight });
    }
  }, [ulRef, chatMessages]);
  React81.useEffect(() => {
    var _a2, _b2, _c, _d, _e;
    if (!layoutContext || chatMessages.length === 0) {
      return;
    }
    if (((_a2 = layoutContext.widget.state) == null ? void 0 : _a2.showChat) && chatMessages.length > 0 && lastReadMsgAt.current !== ((_b2 = chatMessages[chatMessages.length - 1]) == null ? void 0 : _b2.timestamp)) {
      lastReadMsgAt.current = (_c = chatMessages[chatMessages.length - 1]) == null ? void 0 : _c.timestamp;
      return;
    }
    const unreadMessageCount = chatMessages.filter(
      (msg) => !lastReadMsgAt.current || msg.timestamp > lastReadMsgAt.current
    ).length;
    const { widget } = layoutContext;
    if (unreadMessageCount > 0 && ((_d = widget.state) == null ? void 0 : _d.unreadMessages) !== unreadMessageCount) {
      (_e = widget.dispatch) == null ? void 0 : _e.call(widget, { msg: "unread_msg", count: unreadMessageCount });
    }
  }, [chatMessages, layoutContext == null ? void 0 : layoutContext.widget]);
  return /* @__PURE__ */ React81.createElement("div", __spreadProps(__spreadValues({}, props), { className: "lk-chat" }), /* @__PURE__ */ React81.createElement("div", { className: "lk-chat-header" }, "Messages", /* @__PURE__ */ React81.createElement(ChatToggle, { className: "lk-close-button" }, /* @__PURE__ */ React81.createElement(ChatCloseIcon_default, null))), /* @__PURE__ */ React81.createElement("ul", { className: "lk-list lk-chat-messages", ref: ulRef }, props.children ? chatMessages.map(
    (msg, idx) => {
      var _a2;
      return cloneSingleChild(props.children, {
        entry: msg,
        key: (_a2 = msg.id) != null ? _a2 : idx,
        messageFormatter
      });
    }
  ) : chatMessages.map((msg, idx, allMsg) => {
    var _a2;
    const hideName = idx >= 1 && allMsg[idx - 1].from === msg.from;
    const hideTimestamp = idx >= 1 && msg.timestamp - allMsg[idx - 1].timestamp < 6e4;
    return /* @__PURE__ */ React81.createElement(
      ChatEntry,
      {
        key: (_a2 = msg.id) != null ? _a2 : idx,
        hideName,
        hideTimestamp: hideName === false ? false : hideTimestamp,
        entry: msg,
        messageFormatter
      }
    );
  })), /* @__PURE__ */ React81.createElement("form", { className: "lk-chat-form", onSubmit: handleSubmit }, /* @__PURE__ */ React81.createElement(
    "input",
    {
      className: "lk-form-control lk-chat-form-input",
      disabled: isSending,
      ref: inputRef,
      type: "text",
      placeholder: "Enter a message...",
      onInput: (ev) => ev.stopPropagation(),
      onKeyDown: (ev) => ev.stopPropagation(),
      onKeyUp: (ev) => ev.stopPropagation()
    }
  ), /* @__PURE__ */ React81.createElement("button", { type: "submit", className: "lk-button lk-chat-form-button", disabled: isSending }, "Send")));
}

// src/prefabs/PreJoin.tsx
import {
  createLocalAudioTrack,
  createLocalTracks,
  createLocalVideoTrack,
  facingModeFromLocalTrack as facingModeFromLocalTrack2,
  Track as Track7,
  VideoPresets,
  Mutex
} from "livekit-client";
import * as React84 from "react";

// src/prefabs/MediaDeviceMenu.tsx
import { computeMenuPosition, wasClickOutside } from "@livekit/components-core";
import * as React82 from "react";
import { log as log9 } from "@livekit/components-core";
function MediaDeviceMenu(_a) {
  var _b = _a, {
    kind,
    initialSelection,
    onActiveDeviceChange,
    tracks,
    requestPermissions = false
  } = _b, props = __objRest(_b, [
    "kind",
    "initialSelection",
    "onActiveDeviceChange",
    "tracks",
    "requestPermissions"
  ]);
  const [isOpen, setIsOpen] = React82.useState(false);
  const [devices, setDevices] = React82.useState([]);
  const [updateRequired, setUpdateRequired] = React82.useState(true);
  const [needPermissions, setNeedPermissions] = React82.useState(requestPermissions);
  const handleActiveDeviceChange = (kind2, deviceId) => {
    log9.debug("handle device change");
    setIsOpen(false);
    onActiveDeviceChange == null ? void 0 : onActiveDeviceChange(kind2, deviceId);
  };
  const button = React82.useRef(null);
  const tooltip = React82.useRef(null);
  React82.useLayoutEffect(() => {
    if (isOpen) {
      setNeedPermissions(true);
    }
  }, [isOpen]);
  React82.useLayoutEffect(() => {
    if (button.current && tooltip.current && (devices || updateRequired)) {
      computeMenuPosition(button.current, tooltip.current).then(({ x, y }) => {
        if (tooltip.current) {
          Object.assign(tooltip.current.style, { left: `${x}px`, top: `${y}px` });
        }
      });
    }
    setUpdateRequired(false);
  }, [button, tooltip, devices, updateRequired]);
  const handleClickOutside = React82.useCallback(
    (event) => {
      if (!tooltip.current) {
        return;
      }
      if (event.target === button.current) {
        return;
      }
      if (isOpen && wasClickOutside(tooltip.current, event)) {
        setIsOpen(false);
      }
    },
    [isOpen, tooltip, button]
  );
  React82.useEffect(() => {
    document.addEventListener("click", handleClickOutside);
    window.addEventListener("resize", () => setUpdateRequired(true));
    return () => {
      document.removeEventListener("click", handleClickOutside);
      window.removeEventListener("resize", () => setUpdateRequired(true));
    };
  }, [handleClickOutside, setUpdateRequired]);
  return /* @__PURE__ */ React82.createElement(React82.Fragment, null, /* @__PURE__ */ React82.createElement(
    "button",
    __spreadProps(__spreadValues({
      className: "lk-button lk-button-menu",
      "aria-pressed": isOpen
    }, props), {
      onClick: () => setIsOpen(!isOpen),
      ref: button
    }),
    props.children
  ), !props.disabled && /* @__PURE__ */ React82.createElement(
    "div",
    {
      className: "lk-device-menu",
      ref: tooltip,
      style: { visibility: isOpen ? "visible" : "hidden" }
    },
    kind ? /* @__PURE__ */ React82.createElement(
      MediaDeviceSelect,
      {
        initialSelection,
        onActiveDeviceChange: (deviceId) => handleActiveDeviceChange(kind, deviceId),
        onDeviceListChange: setDevices,
        kind,
        track: tracks == null ? void 0 : tracks[kind],
        requestPermissions: needPermissions
      }
    ) : /* @__PURE__ */ React82.createElement(React82.Fragment, null, /* @__PURE__ */ React82.createElement("div", { className: "lk-device-menu-heading" }, "Audio inputs"), /* @__PURE__ */ React82.createElement(
      MediaDeviceSelect,
      {
        kind: "audioinput",
        onActiveDeviceChange: (deviceId) => handleActiveDeviceChange("audioinput", deviceId),
        onDeviceListChange: setDevices,
        track: tracks == null ? void 0 : tracks.audioinput,
        requestPermissions: needPermissions
      }
    ), /* @__PURE__ */ React82.createElement("div", { className: "lk-device-menu-heading" }, "Video inputs"), /* @__PURE__ */ React82.createElement(
      MediaDeviceSelect,
      {
        kind: "videoinput",
        onActiveDeviceChange: (deviceId) => handleActiveDeviceChange("videoinput", deviceId),
        onDeviceListChange: setDevices,
        track: tracks == null ? void 0 : tracks.videoinput,
        requestPermissions: needPermissions
      }
    ))
  ));
}

// src/prefabs/PreJoin.tsx
import { log as log10 } from "@livekit/components-core";

// src/hooks/useWarnAboutMissingStyles.ts
import * as React83 from "react";
function useWarnAboutMissingStyles() {
  React83.useEffect(() => {
    warnAboutMissingStyles();
  }, []);
}

// src/prefabs/PreJoin.tsx
import { defaultUserChoices } from "@livekit/components-core";
function usePreviewTracks(options, onError) {
  const [tracks, setTracks] = React84.useState();
  const trackLock = React84.useMemo(() => new Mutex(), []);
  React84.useEffect(() => {
    let needsCleanup = false;
    let localTracks = [];
    trackLock.lock().then((unlock) => __async(this, null, function* () {
      try {
        if (options.audio || options.video) {
          localTracks = yield createLocalTracks(options);
          if (needsCleanup) {
            localTracks.forEach((tr) => tr.stop());
          } else {
            setTracks(localTracks);
          }
        }
      } catch (e) {
        if (onError && e instanceof Error) {
          onError(e);
        } else {
          log10.error(e);
        }
      } finally {
        unlock();
      }
    }));
    return () => {
      needsCleanup = true;
      localTracks.forEach((track) => {
        track.stop();
      });
    };
  }, [JSON.stringify(options), onError, trackLock]);
  return tracks;
}
function usePreviewDevice(enabled, deviceId, kind) {
  const [deviceError, setDeviceError] = React84.useState(null);
  const [isCreatingTrack, setIsCreatingTrack] = React84.useState(false);
  const devices = useMediaDevices({ kind });
  const [selectedDevice, setSelectedDevice] = React84.useState(
    void 0
  );
  const [localTrack, setLocalTrack] = React84.useState();
  const [localDeviceId, setLocalDeviceId] = React84.useState(deviceId);
  React84.useEffect(() => {
    setLocalDeviceId(deviceId);
  }, [deviceId]);
  const createTrack = (deviceId2, kind2) => __async(this, null, function* () {
    try {
      const track = kind2 === "videoinput" ? yield createLocalVideoTrack({
        deviceId: deviceId2,
        resolution: VideoPresets.h720.resolution
      }) : yield createLocalAudioTrack({ deviceId: deviceId2 });
      const newDeviceId = yield track.getDeviceId();
      if (newDeviceId && deviceId2 !== newDeviceId) {
        prevDeviceId.current = newDeviceId;
        setLocalDeviceId(newDeviceId);
      }
      setLocalTrack(track);
    } catch (e) {
      if (e instanceof Error) {
        setDeviceError(e);
      }
    }
  });
  const switchDevice = (track, id) => __async(this, null, function* () {
    yield track.setDeviceId(id);
    prevDeviceId.current = id;
  });
  const prevDeviceId = React84.useRef(localDeviceId);
  React84.useEffect(() => {
    if (enabled && !localTrack && !deviceError && !isCreatingTrack) {
      log10.debug("creating track", kind);
      setIsCreatingTrack(true);
      createTrack(localDeviceId, kind).finally(() => {
        setIsCreatingTrack(false);
      });
    }
  }, [enabled, localTrack, deviceError, isCreatingTrack]);
  React84.useEffect(() => {
    if (!localTrack) {
      return;
    }
    if (!enabled) {
      log10.debug(`muting ${kind} track`);
      localTrack.mute().then(() => log10.debug(localTrack.mediaStreamTrack));
    } else if ((selectedDevice == null ? void 0 : selectedDevice.deviceId) && prevDeviceId.current !== (selectedDevice == null ? void 0 : selectedDevice.deviceId)) {
      log10.debug(`switching ${kind} device from`, prevDeviceId.current, selectedDevice.deviceId);
      switchDevice(localTrack, selectedDevice.deviceId);
    } else {
      log10.debug(`unmuting local ${kind} track`);
      localTrack.unmute();
    }
  }, [localTrack, selectedDevice, enabled, kind]);
  React84.useEffect(() => {
    return () => {
      if (localTrack) {
        log10.debug(`stopping local ${kind} track`);
        localTrack.stop();
        localTrack.mute();
      }
    };
  }, []);
  React84.useEffect(() => {
    setSelectedDevice(devices == null ? void 0 : devices.find((dev) => dev.deviceId === localDeviceId));
  }, [localDeviceId, devices]);
  return {
    selectedDevice,
    localTrack,
    deviceError
  };
}
function PreJoin(_a) {
  var _b = _a, {
    defaults = {},
    onValidate,
    onSubmit,
    onError,
    debug,
    joinLabel = "Join Room",
    micLabel = "Microphone",
    camLabel = "Camera",
    userLabel = "Username",
    persistUserChoices = true
  } = _b, htmlProps = __objRest(_b, [
    "defaults",
    "onValidate",
    "onSubmit",
    "onError",
    "debug",
    "joinLabel",
    "micLabel",
    "camLabel",
    "userLabel",
    "persistUserChoices"
  ]);
  const [userChoices, setUserChoices] = React84.useState(defaultUserChoices);
  const partialDefaults = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, defaults.audioDeviceId !== void 0 && { audioDeviceId: defaults.audioDeviceId }), defaults.videoDeviceId !== void 0 && { videoDeviceId: defaults.videoDeviceId }), defaults.audioEnabled !== void 0 && { audioEnabled: defaults.audioEnabled }), defaults.videoEnabled !== void 0 && { videoEnabled: defaults.videoEnabled }), defaults.username !== void 0 && { username: defaults.username });
  const {
    userChoices: initialUserChoices,
    saveAudioInputDeviceId,
    saveAudioInputEnabled,
    saveVideoInputDeviceId,
    saveVideoInputEnabled,
    saveUsername
  } = usePersistentUserChoices({
    defaults: partialDefaults,
    preventSave: !persistUserChoices,
    preventLoad: !persistUserChoices
  });
  const [audioEnabled, setAudioEnabled] = React84.useState(initialUserChoices.audioEnabled);
  const [videoEnabled, setVideoEnabled] = React84.useState(initialUserChoices.videoEnabled);
  const [audioDeviceId, setAudioDeviceId] = React84.useState(
    initialUserChoices.audioDeviceId
  );
  const [videoDeviceId, setVideoDeviceId] = React84.useState(
    initialUserChoices.videoDeviceId
  );
  const [username, setUsername] = React84.useState(initialUserChoices.username);
  React84.useEffect(() => {
    saveAudioInputEnabled(audioEnabled);
  }, [audioEnabled, saveAudioInputEnabled]);
  React84.useEffect(() => {
    saveVideoInputEnabled(videoEnabled);
  }, [videoEnabled, saveVideoInputEnabled]);
  React84.useEffect(() => {
    saveAudioInputDeviceId(audioDeviceId);
  }, [audioDeviceId, saveAudioInputDeviceId]);
  React84.useEffect(() => {
    saveVideoInputDeviceId(videoDeviceId);
  }, [videoDeviceId, saveVideoInputDeviceId]);
  React84.useEffect(() => {
    saveUsername(username);
  }, [username, saveUsername]);
  const tracks = usePreviewTracks(
    {
      audio: audioEnabled ? { deviceId: initialUserChoices.audioDeviceId } : false,
      video: videoEnabled ? { deviceId: initialUserChoices.videoDeviceId } : false
    },
    onError
  );
  const videoEl = React84.useRef(null);
  const videoTrack = React84.useMemo(
    () => tracks == null ? void 0 : tracks.filter((track) => track.kind === Track7.Kind.Video)[0],
    [tracks]
  );
  const facingMode = React84.useMemo(() => {
    if (videoTrack) {
      const { facingMode: facingMode2 } = facingModeFromLocalTrack2(videoTrack);
      return facingMode2;
    } else {
      return "undefined";
    }
  }, [videoTrack]);
  const audioTrack = React84.useMemo(
    () => tracks == null ? void 0 : tracks.filter((track) => track.kind === Track7.Kind.Audio)[0],
    [tracks]
  );
  React84.useEffect(() => {
    if (videoEl.current && videoTrack) {
      videoTrack.unmute();
      videoTrack.attach(videoEl.current);
    }
    return () => {
      videoTrack == null ? void 0 : videoTrack.detach();
    };
  }, [videoTrack]);
  const [isValid, setIsValid] = React84.useState();
  const handleValidation = React84.useCallback(
    (values) => {
      if (typeof onValidate === "function") {
        return onValidate(values);
      } else {
        return values.username !== "";
      }
    },
    [onValidate]
  );
  React84.useEffect(() => {
    const newUserChoices = {
      username,
      videoEnabled,
      videoDeviceId,
      audioEnabled,
      audioDeviceId
    };
    setUserChoices(newUserChoices);
    setIsValid(handleValidation(newUserChoices));
  }, [username, videoEnabled, handleValidation, audioEnabled, audioDeviceId, videoDeviceId]);
  function handleSubmit(event) {
    event.preventDefault();
    if (handleValidation(userChoices)) {
      if (typeof onSubmit === "function") {
        onSubmit(userChoices);
      }
    } else {
      log10.warn("Validation failed with: ", userChoices);
    }
  }
  useWarnAboutMissingStyles();
  return /* @__PURE__ */ React84.createElement("div", __spreadValues({ className: "lk-prejoin" }, htmlProps), /* @__PURE__ */ React84.createElement("div", { className: "lk-video-container" }, videoTrack && /* @__PURE__ */ React84.createElement("video", { ref: videoEl, width: "1280", height: "720", "data-lk-facing-mode": facingMode }), (!videoTrack || !videoEnabled) && /* @__PURE__ */ React84.createElement("div", { className: "lk-camera-off-note" }, /* @__PURE__ */ React84.createElement(ParticipantPlaceholder_default, null))), /* @__PURE__ */ React84.createElement("div", { className: "lk-button-group-container" }, /* @__PURE__ */ React84.createElement("div", { className: "lk-button-group audio" }, /* @__PURE__ */ React84.createElement(
    TrackToggle,
    {
      initialState: audioEnabled,
      source: Track7.Source.Microphone,
      onChange: (enabled) => setAudioEnabled(enabled)
    },
    micLabel
  ), /* @__PURE__ */ React84.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ React84.createElement(
    MediaDeviceMenu,
    {
      initialSelection: audioDeviceId,
      kind: "audioinput",
      disabled: !audioTrack,
      tracks: { audioinput: audioTrack },
      onActiveDeviceChange: (_, id) => setAudioDeviceId(id)
    }
  ))), /* @__PURE__ */ React84.createElement("div", { className: "lk-button-group video" }, /* @__PURE__ */ React84.createElement(
    TrackToggle,
    {
      initialState: videoEnabled,
      source: Track7.Source.Camera,
      onChange: (enabled) => setVideoEnabled(enabled)
    },
    camLabel
  ), /* @__PURE__ */ React84.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ React84.createElement(
    MediaDeviceMenu,
    {
      initialSelection: videoDeviceId,
      kind: "videoinput",
      disabled: !videoTrack,
      tracks: { videoinput: videoTrack },
      onActiveDeviceChange: (_, id) => setVideoDeviceId(id)
    }
  )))), /* @__PURE__ */ React84.createElement("form", { className: "lk-username-container" }, /* @__PURE__ */ React84.createElement(
    "input",
    {
      className: "lk-form-control",
      id: "username",
      name: "username",
      type: "text",
      defaultValue: username,
      placeholder: userLabel,
      onChange: (inputEl) => setUsername(inputEl.target.value),
      autoComplete: "off"
    }
  ), /* @__PURE__ */ React84.createElement(
    "button",
    {
      className: "lk-button lk-join-button",
      type: "submit",
      onClick: handleSubmit,
      disabled: !isValid
    },
    joinLabel
  )), debug && /* @__PURE__ */ React84.createElement(React84.Fragment, null, /* @__PURE__ */ React84.createElement("strong", null, "User Choices:"), /* @__PURE__ */ React84.createElement("ul", { className: "lk-list", style: { overflow: "hidden", maxWidth: "15rem" } }, /* @__PURE__ */ React84.createElement("li", null, "Username: ", `${userChoices.username}`), /* @__PURE__ */ React84.createElement("li", null, "Video Enabled: ", `${userChoices.videoEnabled}`), /* @__PURE__ */ React84.createElement("li", null, "Audio Enabled: ", `${userChoices.audioEnabled}`), /* @__PURE__ */ React84.createElement("li", null, "Video Device: ", `${userChoices.videoDeviceId}`), /* @__PURE__ */ React84.createElement("li", null, "Audio Device: ", `${userChoices.audioDeviceId}`))));
}

// src/prefabs/VideoConference.tsx
import { isEqualTrackRef, isTrackReference as isTrackReference5, isWeb, log as log11 } from "@livekit/components-core";
import { RoomEvent as RoomEvent2, Track as Track9 } from "livekit-client";
import * as React89 from "react";

// src/prefabs/ControlBar.tsx
import { Track as Track8 } from "livekit-client";
import * as React88 from "react";
import { supportsScreenSharing } from "@livekit/components-core";

// src/components/controls/StartMediaButton.tsx
import * as React85 from "react";
var StartMediaButton = /* @__PURE__ */ React85.forwardRef(
  function StartMediaButton2(_a, ref) {
    var _b = _a, { label } = _b, props = __objRest(_b, ["label"]);
    const room = useRoomContext();
    const { mergedProps: audioProps, canPlayAudio } = useStartAudio({ room, props });
    const { mergedProps, canPlayVideo } = useStartVideo({ room, props: audioProps });
    const _a2 = mergedProps, { style } = _a2, restProps = __objRest(_a2, ["style"]);
    style.display = canPlayAudio && canPlayVideo ? "none" : "block";
    return /* @__PURE__ */ React85.createElement("button", __spreadValues({ ref, style }, restProps), label != null ? label : `Start ${!canPlayAudio ? "Audio" : "Video"}`);
  }
);

// src/components/controls/SettingsMenuToggle.tsx
import * as React87 from "react";

// src/hooks/useSettingsToggle.ts
import * as React86 from "react";
function useSettingsToggle({ props }) {
  const { dispatch, state } = useLayoutContext().widget;
  const className = "lk-button lk-settings-toggle";
  const mergedProps = React86.useMemo(() => {
    return mergeProps(props, {
      className,
      onClick: () => {
        if (dispatch) dispatch({ msg: "toggle_settings" });
      },
      "aria-pressed": (state == null ? void 0 : state.showSettings) ? "true" : "false"
    });
  }, [props, className, dispatch, state]);
  return { mergedProps };
}

// src/components/controls/SettingsMenuToggle.tsx
var SettingsMenuToggle = /* @__PURE__ */ React87.forwardRef(
  function SettingsMenuToggle2(props, ref) {
    const { mergedProps } = useSettingsToggle({ props });
    return /* @__PURE__ */ React87.createElement("button", __spreadValues({ ref }, mergedProps), props.children);
  }
);

// src/prefabs/ControlBar.tsx
function ControlBar(_a) {
  var _b = _a, {
    variation,
    controls,
    saveUserChoices: saveUserChoices2 = true
  } = _b, props = __objRest(_b, [
    "variation",
    "controls",
    "saveUserChoices"
  ]);
  var _a2, _b2, _c, _d, _e;
  const [isChatOpen, setIsChatOpen] = React88.useState(false);
  const layoutContext = useMaybeLayoutContext();
  React88.useEffect(() => {
    var _a3, _b3;
    if (((_a3 = layoutContext == null ? void 0 : layoutContext.widget.state) == null ? void 0 : _a3.showChat) !== void 0) {
      setIsChatOpen((_b3 = layoutContext == null ? void 0 : layoutContext.widget.state) == null ? void 0 : _b3.showChat);
    }
  }, [(_a2 = layoutContext == null ? void 0 : layoutContext.widget.state) == null ? void 0 : _a2.showChat]);
  const isTooLittleSpace = useMediaQuery(`(max-width: ${isChatOpen ? 1e3 : 760}px)`);
  const defaultVariation = isTooLittleSpace ? "minimal" : "verbose";
  variation != null ? variation : variation = defaultVariation;
  const visibleControls = __spreadValues({ leave: true }, controls);
  const localPermissions = useLocalParticipantPermissions();
  if (!localPermissions) {
    visibleControls.camera = false;
    visibleControls.chat = false;
    visibleControls.microphone = false;
    visibleControls.screenShare = false;
  } else {
    (_b2 = visibleControls.camera) != null ? _b2 : visibleControls.camera = localPermissions.canPublish;
    (_c = visibleControls.microphone) != null ? _c : visibleControls.microphone = localPermissions.canPublish;
    (_d = visibleControls.screenShare) != null ? _d : visibleControls.screenShare = localPermissions.canPublish;
    (_e = visibleControls.chat) != null ? _e : visibleControls.chat = localPermissions.canPublishData && (controls == null ? void 0 : controls.chat);
  }
  const showIcon = React88.useMemo(
    () => variation === "minimal" || variation === "verbose",
    [variation]
  );
  const showText = React88.useMemo(
    () => variation === "textOnly" || variation === "verbose",
    [variation]
  );
  const browserSupportsScreenSharing = supportsScreenSharing();
  const [isScreenShareEnabled, setIsScreenShareEnabled] = React88.useState(false);
  const onScreenShareChange = React88.useCallback(
    (enabled) => {
      setIsScreenShareEnabled(enabled);
    },
    [setIsScreenShareEnabled]
  );
  const htmlProps = mergeProps2({ className: "lk-control-bar" }, props);
  const {
    saveAudioInputEnabled,
    saveVideoInputEnabled,
    saveAudioInputDeviceId,
    saveVideoInputDeviceId
  } = usePersistentUserChoices({ preventSave: !saveUserChoices2 });
  const microphoneOnChange = React88.useCallback(
    (enabled, isUserInitiated) => isUserInitiated ? saveAudioInputEnabled(enabled) : null,
    [saveAudioInputEnabled]
  );
  const cameraOnChange = React88.useCallback(
    (enabled, isUserInitiated) => isUserInitiated ? saveVideoInputEnabled(enabled) : null,
    [saveVideoInputEnabled]
  );
  return /* @__PURE__ */ React88.createElement("div", __spreadValues({}, htmlProps), visibleControls.microphone && /* @__PURE__ */ React88.createElement("div", { className: "lk-button-group" }, /* @__PURE__ */ React88.createElement(
    TrackToggle,
    {
      source: Track8.Source.Microphone,
      showIcon,
      onChange: microphoneOnChange
    },
    showText && "Microphone"
  ), /* @__PURE__ */ React88.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ React88.createElement(
    MediaDeviceMenu,
    {
      kind: "audioinput",
      onActiveDeviceChange: (_kind, deviceId) => saveAudioInputDeviceId(deviceId != null ? deviceId : "")
    }
  ))), visibleControls.camera && /* @__PURE__ */ React88.createElement("div", { className: "lk-button-group" }, /* @__PURE__ */ React88.createElement(TrackToggle, { source: Track8.Source.Camera, showIcon, onChange: cameraOnChange }, showText && "Camera"), /* @__PURE__ */ React88.createElement("div", { className: "lk-button-group-menu" }, /* @__PURE__ */ React88.createElement(
    MediaDeviceMenu,
    {
      kind: "videoinput",
      onActiveDeviceChange: (_kind, deviceId) => saveVideoInputDeviceId(deviceId != null ? deviceId : "")
    }
  ))), visibleControls.screenShare && browserSupportsScreenSharing && /* @__PURE__ */ React88.createElement(
    TrackToggle,
    {
      source: Track8.Source.ScreenShare,
      captureOptions: { audio: true, selfBrowserSurface: "include" },
      showIcon,
      onChange: onScreenShareChange
    },
    showText && (isScreenShareEnabled ? "Stop screen share" : "Share screen")
  ), visibleControls.chat && /* @__PURE__ */ React88.createElement(ChatToggle, null, showIcon && /* @__PURE__ */ React88.createElement(ChatIcon_default, null), showText && "Chat"), visibleControls.settings && /* @__PURE__ */ React88.createElement(SettingsMenuToggle, null, showIcon && /* @__PURE__ */ React88.createElement(GearIcon_default, null), showText && "Settings"), visibleControls.leave && /* @__PURE__ */ React88.createElement(DisconnectButton, null, showIcon && /* @__PURE__ */ React88.createElement(LeaveIcon_default, null), showText && "Leave"), /* @__PURE__ */ React88.createElement(StartMediaButton, null));
}

// src/prefabs/VideoConference.tsx
function VideoConference(_a) {
  var _b = _a, {
    chatMessageFormatter,
    chatMessageDecoder,
    chatMessageEncoder,
    SettingsComponent
  } = _b, props = __objRest(_b, [
    "chatMessageFormatter",
    "chatMessageDecoder",
    "chatMessageEncoder",
    "SettingsComponent"
  ]);
  var _a2, _b2;
  const [widgetState, setWidgetState] = React89.useState({
    showChat: false,
    unreadMessages: 0,
    showSettings: false
  });
  const lastAutoFocusedScreenShareTrack = React89.useRef(null);
  const tracks = useTracks(
    [
      { source: Track9.Source.Camera, withPlaceholder: true },
      { source: Track9.Source.ScreenShare, withPlaceholder: false }
    ],
    { updateOnlyOn: [RoomEvent2.ActiveSpeakersChanged], onlySubscribed: false }
  );
  const widgetUpdate = (state) => {
    log11.debug("updating widget state", state);
    setWidgetState(state);
  };
  const layoutContext = useCreateLayoutContext();
  const screenShareTracks = tracks.filter(isTrackReference5).filter((track) => track.publication.source === Track9.Source.ScreenShare);
  const focusTrack = (_a2 = usePinnedTracks(layoutContext)) == null ? void 0 : _a2[0];
  const carouselTracks = tracks.filter((track) => !isEqualTrackRef(track, focusTrack));
  React89.useEffect(() => {
    var _a3, _b3, _c, _d, _e, _f;
    if (screenShareTracks.some((track) => track.publication.isSubscribed) && lastAutoFocusedScreenShareTrack.current === null) {
      log11.debug("Auto set screen share focus:", { newScreenShareTrack: screenShareTracks[0] });
      (_b3 = (_a3 = layoutContext.pin).dispatch) == null ? void 0 : _b3.call(_a3, { msg: "set_pin", trackReference: screenShareTracks[0] });
      lastAutoFocusedScreenShareTrack.current = screenShareTracks[0];
    } else if (lastAutoFocusedScreenShareTrack.current && !screenShareTracks.some(
      (track) => {
        var _a4, _b4;
        return track.publication.trackSid === ((_b4 = (_a4 = lastAutoFocusedScreenShareTrack.current) == null ? void 0 : _a4.publication) == null ? void 0 : _b4.trackSid);
      }
    )) {
      log11.debug("Auto clearing screen share focus.");
      (_d = (_c = layoutContext.pin).dispatch) == null ? void 0 : _d.call(_c, { msg: "clear_pin" });
      lastAutoFocusedScreenShareTrack.current = null;
    }
    if (focusTrack && !isTrackReference5(focusTrack)) {
      const updatedFocusTrack = tracks.find(
        (tr) => tr.participant.identity === focusTrack.participant.identity && tr.source === focusTrack.source
      );
      if (updatedFocusTrack !== focusTrack && isTrackReference5(updatedFocusTrack)) {
        (_f = (_e = layoutContext.pin).dispatch) == null ? void 0 : _f.call(_e, { msg: "set_pin", trackReference: updatedFocusTrack });
      }
    }
  }, [
    screenShareTracks.map((ref) => `${ref.publication.trackSid}_${ref.publication.isSubscribed}`).join(),
    (_b2 = focusTrack == null ? void 0 : focusTrack.publication) == null ? void 0 : _b2.trackSid,
    tracks
  ]);
  useWarnAboutMissingStyles();
  return /* @__PURE__ */ React89.createElement("div", __spreadValues({ className: "lk-video-conference" }, props), isWeb() && /* @__PURE__ */ React89.createElement(
    LayoutContextProvider,
    {
      value: layoutContext,
      onWidgetChange: widgetUpdate
    },
    /* @__PURE__ */ React89.createElement("div", { className: "lk-video-conference-inner" }, !focusTrack ? /* @__PURE__ */ React89.createElement("div", { className: "lk-grid-layout-wrapper" }, /* @__PURE__ */ React89.createElement(GridLayout, { tracks }, /* @__PURE__ */ React89.createElement(ParticipantTile, null))) : /* @__PURE__ */ React89.createElement("div", { className: "lk-focus-layout-wrapper" }, /* @__PURE__ */ React89.createElement(FocusLayoutContainer, null, /* @__PURE__ */ React89.createElement(CarouselLayout, { tracks: carouselTracks }, /* @__PURE__ */ React89.createElement(ParticipantTile, null)), focusTrack && /* @__PURE__ */ React89.createElement(FocusLayout, { trackRef: focusTrack }))), /* @__PURE__ */ React89.createElement(ControlBar, { controls: { chat: true, settings: !!SettingsComponent } })),
    /* @__PURE__ */ React89.createElement(
      Chat,
      {
        style: { display: widgetState.showChat ? "grid" : "none" },
        messageFormatter: chatMessageFormatter,
        messageEncoder: chatMessageEncoder,
        messageDecoder: chatMessageDecoder
      }
    ),
    SettingsComponent && /* @__PURE__ */ React89.createElement(
      "div",
      {
        className: "lk-settings-menu-modal",
        style: { display: widgetState.showSettings ? "block" : "none" }
      },
      /* @__PURE__ */ React89.createElement(SettingsComponent, null)
    )
  ), /* @__PURE__ */ React89.createElement(RoomAudioRenderer, null), /* @__PURE__ */ React89.createElement(ConnectionStateToast, null));
}

// src/prefabs/AudioConference.tsx
import * as React90 from "react";
import { Track as Track10 } from "livekit-client";
function AudioConference(_a) {
  var props = __objRest(_a, []);
  const [widgetState, setWidgetState] = React90.useState({
    showChat: false,
    unreadMessages: 0
  });
  const audioTracks = useTracks([Track10.Source.Microphone]);
  useWarnAboutMissingStyles();
  return /* @__PURE__ */ React90.createElement(LayoutContextProvider, { onWidgetChange: setWidgetState }, /* @__PURE__ */ React90.createElement("div", __spreadValues({ className: "lk-audio-conference" }, props), /* @__PURE__ */ React90.createElement("div", { className: "lk-audio-conference-stage" }, /* @__PURE__ */ React90.createElement(TrackLoop, { tracks: audioTracks }, /* @__PURE__ */ React90.createElement(ParticipantAudioTile, null))), /* @__PURE__ */ React90.createElement(
    ControlBar,
    {
      controls: { microphone: true, screenShare: false, camera: false, chat: true }
    }
  ), widgetState.showChat && /* @__PURE__ */ React90.createElement(Chat, null)));
}
export {
  AudioConference,
  Chat,
  ControlBar,
  MediaDeviceMenu,
  PreJoin,
  VideoConference,
  usePreviewDevice,
  usePreviewTracks
};
//# sourceMappingURL=index.mjs.map